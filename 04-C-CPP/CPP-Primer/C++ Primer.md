# C++ Primer

- [ ] 书籍作者：李普曼（Lippman,S.B.），拉乔伊（Lajoie,J.），（美）默（Moo,B.E.）
- [ ] 笔记时间：2021.9.1

# Ⅰ 基础

## 第1章 预备知识

- 20世纪70年代，贝尔实验室为了开发Unix系统发明了C语言。此时提出了结构化编程，和自顶向下的设计。强调的是算法。

  数据（黄油，糖，鸡蛋）+	算法（奶油，加糖，打鸡蛋）→	程序（蛋糕）

- 20世纪80年代贝尔实验室开发。应对编写大型程序时带来挑战，出现了OOP，强调的是数据。带来的是自下向上的设计。
- C++的标准是ANSI/ISO C++
- 编译和链接
  - Unix系统：CC调用cfront，将C++生成C文件，再由C把编译器处理
  - Linux系统：使用的是g++，来自GNU
  - Windows系统：使用的是Cygwin和MinGW，当然也有GNU C++。祖传MSVC。
  - Macintosh系统：使用Xcode

## 第2章 变量和基本数据类型

- 规则

  - 在dll不需要main，但是在特殊环境（机器人芯片，框架）可能会隐藏地调用main()，调用_tmain()

  - 预处理：预处理器将用到的文件内容添加到程序里，头文件没有后缀

  - 名称空间：使用using编译指令可以方便引入；用于隔离程序；

  - ```c++
    // C++ 主函数格式
    int main(){
    	return 0;
    }
    ```

- 语句 变量声明、赋值、函数、cout、cin

- 多种类型声明解读

  ```c++
  const int * p = nullptr;
  (const int) * p = nullptr;// 表示 常量int类型指针p
  (const int) & p = nullptr;// 表示 常量int类型引用p
  ( int*) & p = nullptr;// 表示 int指针类型引用p
  ```

  

- constexpr 与 const

  > 顶层const表示指针本身是常量,这时候使用constexpr更合适
  >
  > 底层const表示指针指向的对象是常量
  >
  > constexpr 对应的是变量本身是常量,
  >
  > const对应的是 只读变量,只读变量是可以被改变的

- auto / decltype

  > auto 自动类型推断,可以在使用const和&指定常量和引用推断,对顶层const不会保留
  >
  > decltype 可以只获取类型而不使用值进行初始化,比如使用某个函数返回类型,对顶层const也会保留
  >
  > decltype 可以返回引用但是需要初始化,decltype((i))永远返回i类型引用

- 

## 第3章 字符串 向量 数组

- 数值类型没有固定长度，可以使用 sizeof 进行查看；可以使用花括号初始化  

- ```c++
  cout << hex << 123 << endl;// 7b
  cout.put('$');	//$
  cout << '$';	//36,Relase2.0以后不会打印ASCII码
  cout << \u222B;	//∫
  ```

- using可以引入命名空间/变量等,这样就可以省略名称空间的编写;

  可以单独引入类型/变量,或者整个名称空间

  头文件最好不要using声明,因为头文件内容会直接拷贝

- std::string

  - =初始化是拷贝初始化,string(var)是直接初始化

  - string类型来说不管是哪种初始化都是拷贝,原变量改变不会影响新变量

  - 自带实现各种操作符和方法,size()方法返回字符串长度,类型是string::size_type

    使用typeid查看是unsigned int

  - 需要注意的是string类型和字面量字符串**不是**同一种类型,所以会出现字面量相加报错的现象.但是还是以'\0'结尾的

- cctype

  - c++中把c的头文件都改写为cXXX,比如ctype.h ==> cctype

  - 含有各种判断字符的操作,字母 数字 大小写 等,支持迭代器,

    假如迭代过程使用引用,可以边遍历边修改

  - 需要注意字符串的size()返回类型不是int,而是特殊的size_type,需要使用decltype

- vector

  - 属于模板类,由于引用不是对象,所以不可以放进去,编译就报错
  - 支持列表初始化
  - vector 可以高效增长,提前指定容量不见得是好的行为
  - vector\<T\>::size_type和string::size_type的一致
  
- 迭代器

  - 容器类含有begin()和end()可以返回对应的迭代器对象,属于指针类型,取值需要解引用
  - 使用迭代器就不要在循环体内往容器添加对象
  - 迭代器重载了很多运算符,支持++ / -- / +N / ....

- 数组

  - 长度必须是常量,可以是使用constexpr修饰的变量

  - 不允许赋值和拷贝,有些编译器支持,称为编译器扩展,不具有通用性

  - ```c++
    int *arr[10] = a			// 元素是指针类型
    int (*arr)[10] = a			// 元素是整型
    int* (&arr)[10] = a    		// 元素是指针类型,本身是数组的引用
    int (&arr)[10] ;			// 不可以直接声明引用,必须初始化   
    ```

  - 数组名字是指针,指向首个元素的位置,下标可以是负数

  - 指针相减的结果类型是ptrdiff_t,在cstddef头文件

  - 使用增强for时候声明为引用类型可以避免编译器使用指针

## 第4章 表达式

- 左值用的是对象的内存位置,右值用的是对象的内容

- 求值顺序只有四种运算符规定(&&  ||  ?:  , ),其余就是优先级和结合律,不可以认为就是从左往右

  比如 cout<< ++i 就会产生不确定性

- sizeof 对容器处理是返回该类型固定部分多少而不是元素占用多少,string也是

- ```c++
  *iter++    ===>  *(iter++)
  int nums[3]={1,2,3};	//可以使用 new 绕过大小限制
  short things[] = {1,2,3,4};
  int len = sizeof things / sizeof short;	//获取个数
  cin.getline();
  cin.get();				//留下换行符
  R("abc");				//R表示Row，("表示定界符开始
  int* arr = new int[10];
  delete [] arr;			//创建、释放对象
  ```

- cin.get() 读取空行后会设置失效位，使用clear()恢复。当字符串过长，getline()会留下字符并设置失效位。

- 显示转换

  - static_cast,只要不包含底层const

  - const_cast只能改变底层const,也就是 指针指向的内容是常量

    称为去掉const性值,如果本身是常量转换后修改,是未定义行为

    常常用于函数重载

  - reinterpret_cast 通常为运算对象的位模式提供较低层次的重新解释

    很危险,避免使用

  - 旧式类型转换,括号.与上述三者作用一致,发生错误较难追踪

- 空语句最好加上注释,尤其小心循环的空语句

- 循环 | 分支判断 | break | continue | try,catch | throw 用法无特殊 

- 内存管理方式

  - 自动存储：函数内部的常规变量
  - 静态存储：使用了static修饰，生命周期可能是类级别
  - 动态存储：new和delete

- 模板类

  - vector是动态数组，自动完成new和delete。效率稍低。
  - array固定长度，跟数据比方便一些。

## 第5章 循环和关系表达式

- 当表达式改变了内存中数据的值，称为表达式有副作用；比如c++

- 顺序点是程序执行过程的一个点，此处确保对前面所有的副作用进行了评估。

- 建立别名可以使用 #define 或者 typedef。

- C++11支持foreach

- cin 测试到达结尾可以使用 fail() / eof() 来获取输入结束，有可能使用-1来表示EOF，

  但是char 表示不了负数，可以以此为判断条件 。

- cin 的>>具有返回值，输入错误会得到0

## 第6章 函数

- 局部静态对象,在程序执行路径第一次经过对象定义语句初始化,直到程序终止才销毁

- 不可以拷贝数组,通常数组是指针形式,所以形参没有值传递的形式

  可以使用常量指针

  - 传入begin()和end()对象
  - 传入数组长度
  - 传入数组结尾字符/分隔符等

- 多维数组是指针数组,所以需要括号

- 可变形参

  - initializer_list 实参数量未知,形参类型一致,是一个模板类型,使用方法同vector
  - 省略符形式

- 返回值默认返回值类型,需要共享则明确使用引用

  - 不要返回局部对象的指针或者引用,
  - 可以返回列表初始化对象
  - 数组对象返回指针
  - 尾置返回类型可以明确函数返回的类型,一般用于复杂函数返回类型,限制auto
  - 返回类型可以使用 decltype 进行声明

- 函数重载

  - 无法区分顶层const,也就是指针执行的是否为常量
  - 此时就可以使用const_cast,比如返回较短的字符串

- 特殊用途特性

  - 默认实参,直接参数后面接等号,适合放在头文件里面,可以没有参数名
  - 内联函数,可以避免函数调用的额外开销,直接源码替换调用
  - constexpr函数,被隐式指定位内联函数,返回类型和所有形参都要是字面值类型
  - 后两者一般直接放在头文件

- 调试

  - assert是预处理宏,依赖NDEBUG预处理变量,默认该变量没有定义

- 函数本身也是指针

  - ```c++
    using F = int(int*,int); 		// 函数类型
    using FP = int(*)(int*,int); 	// 指针类型
    Pf f1(int);						// f1返回指向函数的指针
    auto f1(int) -> int(*)(int*,int);
    ```


  - 使用 auto 和 decltype 指明函数指针类型


## 第7章 类

- 函数后面加const表示不可以修改类成员,称为常量 成员函数

  伪代码 std::string  Student::func(const Student* const this)

- 构造器

  - Student() = default; 表示该构造器不接受参数,是默认构造器
  - 支持列表初始化,Studen():xxx(),xxx()
  - 委托构造函数,调用重载的构造函数
  - 转换构造函数,使用explict修饰可以抑制,参数带有相应的类型即可

- 友元

  - 允许非成员函数访问类非公有成员,假如很多都要访问,直接使用getter更好

    操作符重载使用友元比较方便

- 聚合类
  - struct 和 class 唯一差别在于访问权限,前者public,后者private
  - 全是public成员,没有初始值,没有继承,多态称为聚合类,可以使用列表初始化对象
  - 字面值常量类,聚合类成员都是常量,构造函数可以使用constexpr修饰



# Ⅱ 标准库  

## 第8章 IO库

- iostream / fstream / sstream 分别是 流读写/文件读写/字符串读写

- io对象不能拷贝/赋值,只能使用引用传递

  - 具有各种状态以及查看函数,比如结尾/溢出/异常等

  - 缓冲区刷新 -- 程序正常结束/缓冲区满/显示刷新/关联别的流

    使用endl/flush/ends/unitbuf 等显示刷新

  - 当流对象被销毁时,会自动调用close


## 第9章 顺序容器

- array/string/vector是顺序存储,list和deque是链表实现
  - 默认使用vector,array支持复制/赋值
  - 很多小元素,空间要求高,使用list
  - 假如需要插入容器中间,之后又要随机访问.建议先用list承接输入,之后转vector进行查询
- 一些操作
  - 迭代器 iterator,可以使用begin()和end() ,属于左闭右开
  - 容器初始化支持赋值/复制/列表初始化
  - assign 可以令array支持不同但兼容的类型赋值
  - swap会交换内部数据结构,常数时间内(array除外)
  - emplace会构造元素而不是复制元素
- 迭代器失效
  - 添加元素后 vector/string 指向的便不是同一个对象了,删除后迭代器有效
  - deque插入头尾之外位置会导致失效,删除也会失效
  - list不受影响
  - 不要保存end()返回的迭代器,end()在增删操作后会失效

- vector扩增机制
  - 翻倍,可以通过reserve()指定容量

- string操作: find/substr/compare/stod
- 容器适配器: 基于前面容器的实现,比如deque
  - stack / queue / priority_queue

## 第10章 泛型算法

- 实现在头文件  algorithm 和 numeric 中,算法取决于元素类型,跟容器无关
- 只读算法 -- find / count  / accumulate 

- 算法不检查写操作,要是空容器会发生未定义行为

  - 可以使用back_inserter产生迭代器往空容器填充

- 排序

  - sort / unique / erase

  - 可以接收比较器,也就是一个比较大小的函数,称为谓词

  - lambda表达式,\[捕获参数\](const int& a,const int& b){return a>b;}

    自动推断捕获参数可以使用&或者=

    默认lambda不可以修改捕获参数,使用mutable修饰则可以

    返回类型可以使用尾置法

  - bind()函数可以把可调用参数和形参进行绑定,

    使用占位符进行替代,占位符再placeholders命名空间

    ref函数返回对象的引用

- 迭代器
  - 插入迭代器 -- back_inserter / inserter等
  - 流迭代器 -- istream_iterator 等
  - 反向迭代器 -- 除了 forward_list,其他容器都支持

## 第11章 关联容器

- map 和 set,由于使用键值对,不能顺序迭代
  - multixxx可以让一个键对应多个值
  - set迭代器是const类型的
  - 支持中括号
- 无序容器使用哈希函数和 == 进行元素比较

## 第12章 动态内存

- 智能指针 (memory头文件)

  - shared_ptr  ,也是模板 ,可以多个指针指向同一个对象

    - make_shared 分配内存,返回指针对象

    - 支持拷贝,使用引用计数

    - 会自动调用析构函数并释放关联内存

    - 可以配合new,但是需要提供自己的操作替代delete,建议用make_shared

      不要混合使用new和智能指针

    - 无论是否发生异常,智能指针都可以释放内存,

      对没有默认实现析构释放的对象,可以在使用指针的时候传入自定义的释放函数

  - unique_ptr ,只能自己绑定一个对象,需要自己new一个对象进行绑定

    - 不支持普通拷贝和赋值操作,但是可以在函数里面返回
    - 可以通过release/reset传递指针或者取回指针
    - 旧版本兼容问题使用auto_ptr,建议使用unique版本
    - 传入删除器的时候跟shared_ptr有所不同,需要指明泛型

  - weak_ptr

    - 指向一个shared_ptr指针,不会增加计数
    - 对象可能被释放,使用lock()检查是否被释放
    - 可以用于检查对象是否还有效

- new / delete

  - 成对使用,要很小心内存泄漏问题
  - delete之后重置指针值
  - new[] 和 delete[] 成对使用,动态数组不能算数组而是一个数组元素类型的指针

- 动态数组

  - 一般来说,使用vector等容器类是更好的选择

  - unique指针可以在模板里面传入数组类型,shared指针需要自定义删除器

  - allocator类提供内存分配和对象构造的分离

    使用construct()进行构造                                   

# Ⅲ 类设计工具

## 第13章 拷贝控制

- 拷贝构造函数
  - 第一个参数必须是引用类型,几乎伴随着const.
  - 编译器合成的拷贝函数默认调用类的拷贝方法,对于数组则是逐个元素拷贝
  - 拷贝初始化使用的是 = ,直接初始化是构造器传入参数
  - 还会发生在 参数传递,参数返回,花括号初始化一个数组元素

- 拷贝赋值运算符

- 析构函数,一般在对象要被销毁/离开作用域时被系统调用

- 以上三者在手动分配(new 对象)时候,几乎都是必要的

  前两者一般一起出现

  可以通过 =default 显示要求编译器使用合成构造器

- 可以通过 =delete 阻止拷贝,也可以通过阻止某些函数引导函数匹配

  - 也可以通过private限定

- 如果一个类有数据成员不能默认构造/拷贝/复制/销毁,则对应成员函数将被定义为删除的

  对于引用和const成员就无法默认构造

- 拷贝控制
  - 行为像值(如 string)
    - 需要定义拷贝构造函数(深拷贝),析构函数,拷贝赋值运算符
    - 赋值运算符必须考虑赋值给自身,一般组合了析构函数和拷贝构造函数的工作
  - 行为像指针(如 智能指针)
    - 跟值差别在于引用计数,不用深拷贝
    - 引用计数变量可以放在堆里面,每次拷贝都加一
    - 析构函数只有引用为0的时候才真正释放对象

- 定义swap操作

  - 一般通用的交换操作需要一次拷贝,两次赋值,自定义的时候可以使用指针节省空间/时间

  - ```c++
    class Student{
        friend void swap(Student& a,Studen& b);
    }
    inline void swap(Student& a,Studen& b){
        using std::swap;
        swap(a.x,b.x);    // 交换指针
    }
    
    Student& Student::operator=(Student a){
    	swap(*this,a);
        return *this;
    }
    ```

- 对象移动

  - 右值引用 -- 必须绑定到右值的引用,通过 && 获取,
  - 右值是短暂的,比如 字面量,临时变量
  - 可以通过move获取绑定到左值的右值引用,向编译器保证除了赋值和销毁,不会有别的操作

- 移动构造函数

  - 类似拷贝构造函数,参数使用的是右值引用,一旦移动后就需要把源对象置空并通知标准库
  
  - 可以使用 noexcept 标注移动函数
  
  - 移动构造函数是可以抛出异常的,容器对异常有自己的处理机制;
  
    如果不标注 noexcept ,容器就会使用拷贝构造函数而不是移动构造函数
  
  - 移动后的对象必须可以析构
  
  - 只有一个类没有任何拷贝函数,且成员都是能移动拷贝,编译器才会合成移动构造函数
  
    所以要定义移动构造函数就必须定义拷贝构造/拷贝赋值运算符
  
- 移动迭代器

  - make_move_iterator() 返回一个移动迭代器,用移动替代拷贝
  - 一定要确保对象不再使用才用移动

- 使用 const X& 可以匹配拷贝,X&& 可以匹配右值

  可以在参数列表后面添加 const/& 修饰,表明this可以指向的类型(左值/右值)



## 第14章 重载运算与类型转换

- 重载运算符参数至少含有一个该类对象,this也算

  - = / [] / () / -> 一般是成员,具有对称性的一般非成员
  - 定义成类的成员函数就需要考虑调用对象问题,比如string和char*之间的拼接问题
  - 流的运算符重载具有固定写法,需要注意的是输入流需要检查数据是否已经输入再使用
  - 赋值运算符记得释放当前内存空间,无需检查反身性
  - lambda相当于匿名类,捕获参数相当于成员

- 标准库定义了一组运算类,在functional头文件

  - function类型可以用来表示一类的函数,比如 输入都是两个int,返回一个int

    lambda是类对象也可以

  - 不可以直接区分重载函数,可以使用lambda/函数指针消除二义性

- 类型转换

  - operator type() const;

    一定要慎重使用,因为编译器的隐式转换容易出现意外结果

  - 可以使用explicit修饰,避免隐式转换

  - 避免二义性问题,

    - 两个类之间有相同的类转换
    - 多种内置类型的转换
    - 调用重载函数,如果多个用户定义类型转换提供可行匹配,则认为一样好
    - 类提供目标类型是算术类型转换,也提供重载的运算符就会产生二义性问题

## 第15章 面向对象程序设计

- 继承与多态

  - 类方法使用virtual修饰表示需要字类实现,析构函数需要用virtual修饰

    使用 override  可以帮助检查覆盖

  - 使用作用域运算符可以使用基类的属性

  - 派生类的声明不包含继承,实现才继承;  final 阻止继承

  - 继承的属性默认是private,使用using可以更改级别

  - 友元不可以继承

- 纯虚函数

  - 使用 =0,含有纯虚函数的是抽象类
  - 使用作用域运算符可以强制使用虚函数的特定版本
  - 默认/拷贝/移动构造函数不会继承
  - 同名(参数列表可以不同)函数会隐藏基类的版本
  - 

- 虚析构函数
  - 会阻止移动合成操作
  - 派生类析构函数只负责自己类,还需要手动处理基类的初始化/拷贝等

- 容器与继承
  - 容器中元素使用指针是更好的选择

## 第16章 模板与泛型编程

- 函数模板

  - 函数前一行使用 template \<typename T\> 表明接收一个泛型参数T

    typename 和 class 等价,建议使用前者,便于区分类和模板

  - 定义非类型参数表示一个值而不是一种类型,通过特定类型实例化

  - inline 和 constexpr 放在模板后返回类型之前

  - 类型无关的代码:  模板中参数是const引用,使用<进行比较

- 模板生成

  - 只有实例化之后编译器才会检查正确性
  - 为了实例化模板,编译器需要知道模板的定义,所以模板的头文件包括声明和定义

- 类模板

  - 使用跟函数模板差别不大
  - 处于类模板作用域,编译器处理模板自身引用时就好像提供了模板参数匹配的实参一样
  - 类外使用类模板名需要重新声明类模板
  - 友元与模板可以是多对多/一对一/多对一关系
  - 可以有static成员,同一类型共享
  - 默认通过作用域运算符访问的是名字而不是类型,通过typename T::val 显示指定类型

- 类的成员模板

  - 属于函数模板,差别在于实例化时候不用显示指定类型

- 实例化控制

  - extern template declaration; //实例化声明
  - template declaration;// 实例化定义

- 类型转换

  - 模板参数传参,编译器一般生成模板实例

  - const转换,将一个非const转为const的引用或指针

  - 数组/函数指针转换,如果函数形参不是引用类型,则可以应用正常指针转换

  - 其他类型,比如算术/继承/用户定义转换,都不可以用于函数模板

  - remove_reference可以返回去掉引用的类型,可以配合decltype使用

  - 引用折叠使得 X&& 可以接收 X&类型参数,按时左值/右值都可以传给 X&& 类型

  - ```c++
    template <typename T> void g(T&&);	// 绑定到非const右值
    template <typename T> void g(const T&);	// 左值和const右值
    ```

  - static_cast可以把左值引用转为右值引用

- 转发

  - 通过把参数设置为泛型的右值引用可以保持类型信息的函数参数
  - forward模板方法可以返回该显示实参类型的右值引用

- 重载与模板

  - 多个函数模板重载会选择更特例化的那一个,也就是类型更加匹配(const/指针/引用等判断)
  - 和非函数模板重载参数都符合的话,选择非模板
  - 可变参数,typename...  ,可以使用递归打印参数, ... 也可以用于报扩展
  - 模板特例化实际是替代了编译器的工作,关键字 template\<\>
  - 类模板可以部分特例化,函数模板则必须全部特例化

# Ⅳ 高级主题

## 第17章 标准库特殊设置

- tuple

  - tuple\<string,int,double\> tu = {}

    get\<0\>(tu)

- bitset

  - 使用整型初始化会转成unsigned longlong 直接当成位模式处理
  - string初始化低位和高位相反

- 正则表达式

  - 实在运行时而不是编译时编译的,编译速度很慢,所以不要大量使用

- 随机数

  - 随机数引擎可以生成无符号随机数序列
    - 每个编译器都有一个 default_random_engine
    - 可以把引擎设为static,避免每次输出相同数列
    - 可以给引擎一个种子,方便每次生成相同结果
  - 分布类使用引擎类生成指定类型范围的服从特定分布的随机数

- IO

  - boolalpha 可以输出字符而不是数值的bool值,关闭都是前面加no,如 noboolalpha 
  - oct/dec/hex 格式化输出整型, showbase显示进制
  - get/put可以逐个字符处理
  - 随机访问,seek和tell,p版本移动到表示写指针,g版本表示读指针

## 第18章 用于大型程序的工具

- 异常处理

  - 栈展开:函数发生异常会立即开始寻找匹配的catch语句,逐层往外找,直到找到或者终止

  - 栈展开过程中对象会自动销毁

  - 析构函数总是会被执行,如果异常发生后没有被正确捕获,系统会调用terminate函数,

    不要在析构函数抛出异常

  - 构造函数可以和try写一起,称为函数try语句块

  - noexcept声明函数不会抛异常,假如发生了程序会直接终止

- 命名空间

  - 通常不会把#inclue放到命名空间
  - ::var 表示在全局命名空间定义var
  - 内联命名空间可以被外层命名空间直接使用
  - 未命名空间的变量具有静态生命周期,不具有跨文件
  - 可以给命名空间取别名/使用using
  - using声明是引入一个成员,using指示是让命名空间的所有名字可见
  - using是引入名字而非函数

- 继承

  - 菱形继承需要虚继承

## 第19章 特殊工具与技术

- 内存控制

  - 重载new/delete
    - operator new/delete,可以配合malloc/free使用
  - 运行时识别类型
    - typeid 和 dynamic_cast
    - type_info类
  - 枚举类型
  - 成员指针
    - function生成一个可调用对象,bind/mem_fn也可以
  - 嵌套类/union/
    - union可以有构造函数的类型成员,union判别式确定类型

- 不可移植成员

  - 位域,冒号后面跟着位数

    unsigned int mode:2 表示mode占2位

  - volatile限定符

  - extern "C"