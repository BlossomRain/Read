package com.sun.tools.javac.resources;

public final class compiler extends java.util.ListResourceBundle {
    protected final Object[][] getContents() {
        return new Object[][] {
            { "compiler.err.abstract.cant.be.accessed.directly", "abstract {0} {1} in {2} cannot be accessed directly" },
            { "compiler.err.abstract.cant.be.instantiated", "{0} is abstract; cannot be instantiated" },
            { "compiler.err.abstract.meth.cant.have.body", "abstract methods cannot have a body" },
            { "compiler.err.add.exports.with.release", "exporting a package from system module {0} is not allowed with --release" },
            { "compiler.err.add.reads.with.release", "adding read edges for system module {0} is not allowed with --release" },
            { "compiler.err.addmods.all.module.path.invalid", "--add-modules ALL-MODULE-PATH can only be used when compiling the unnamed module" },
            { "compiler.err.already.annotated", "{0} {1} has already been annotated" },
            { "compiler.err.already.defined", "{0} {1} is already defined in {2} {3}" },
            { "compiler.err.already.defined.in.clinit", "{0} {1} is already defined in {2} of {3} {4}" },
            { "compiler.err.already.defined.single.import", "a type with the same simple name is already defined by the single-type-import of {0}" },
            { "compiler.err.already.defined.static.single.import", "a type with the same simple name is already defined by the static single-type-import of {0}" },
            { "compiler.err.already.defined.this.unit", "{0} is already defined in this compilation unit" },
            { "compiler.err.annotation.decl.not.allowed.here", "annotation type declaration not allowed here" },
            { "compiler.err.annotation.missing.default.value", "annotation @{0} is missing a default value for the element ''{1}''" },
            { "compiler.err.annotation.missing.default.value.1", "annotation @{0} is missing default values for elements {1}" },
            { "compiler.err.annotation.not.valid.for.type", "annotation not valid for an element of type {0}" },
            { "compiler.err.annotation.type.not.applicable", "annotation type not applicable to this kind of declaration" },
            { "compiler.err.annotation.type.not.applicable.to.type", "annotation @{0} not applicable in this type context" },
            { "compiler.err.annotation.value.must.be.annotation", "annotation value must be an annotation" },
            { "compiler.err.annotation.value.must.be.class.literal", "annotation value must be a class literal" },
            { "compiler.err.annotation.value.must.be.name.value", "annotation values must be of the form ''name=value''" },
            { "compiler.err.annotation.value.not.allowable.type", "annotation value not of an allowable type" },
            { "compiler.err.anon.class.impl.intf.no.args", "anonymous class implements interface; cannot have arguments" },
            { "compiler.err.anon.class.impl.intf.no.qual.for.new", "anonymous class implements interface; cannot have qualifier for new" },
            { "compiler.err.anon.class.impl.intf.no.typeargs", "anonymous class implements interface; cannot have type arguments" },
            { "compiler.err.anonymous.diamond.method.does.not.override.superclass", "method does not override or implement a method from a supertype\n{0}" },
            { "compiler.err.array.and.receiver", "legacy array notation not allowed on receiver parameter" },
            { "compiler.err.array.and.varargs", "cannot declare both {0} and {1} in {2}" },
            { "compiler.err.array.dimension.missing", "array dimension missing" },
            { "compiler.err.array.req.but.found", "array required, but {0} found" },
            { "compiler.err.assert.as.identifier", "as of release 1.4, ''assert'' is a keyword, and may not be used as an identifier" },
            { "compiler.err.attribute.value.must.be.constant", "element value must be a constant expression" },
            { "compiler.err.bad.functional.intf.anno", "Unexpected @FunctionalInterface annotation" },
            { "compiler.err.bad.functional.intf.anno.1", "Unexpected @FunctionalInterface annotation\n{0}" },
            { "compiler.err.bad.initializer", "bad initializer for {0}" },
            { "compiler.err.bad.name.for.option", "bad name in value for {0} option: ''{1}''" },
            { "compiler.err.bad.target.sigpoly.call", "polymorphic signature calls are not supported in -target {0}\n(use -target {1} or higher to enable polymorphic signature calls)" },
            { "compiler.err.bad.value.for.option", "bad value for {0} option: ''{1}''" },
            { "compiler.err.break.outside.switch.loop", "break outside switch or loop" },
            { "compiler.err.call.must.be.first.stmt.in.ctor", "call to {0} must be first statement in constructor" },
            { "compiler.err.call.to.super.not.allowed.in.enum.ctor", "call to super not allowed in enum constructor" },
            { "compiler.err.cannot.create.array.with.diamond", "cannot create array with ''<>''" },
            { "compiler.err.cannot.create.array.with.type.arguments", "cannot create array with type arguments" },
            { "compiler.err.cannot.generate.class", "error while generating class {0}\n({1})" },
            { "compiler.err.cant.access", "cannot access {0}\n{1}" },
            { "compiler.err.cant.apply.diamond", "cannot infer type arguments for {0}" },
            { "compiler.err.cant.apply.diamond.1", "cannot infer type arguments for {0}\nreason: {1}" },
            { "compiler.err.cant.apply.symbol", "{0} {1} in {4} {5} cannot be applied to given types;\nrequired: {2}\nfound: {3}\nreason: {6}" },
            { "compiler.err.cant.apply.symbols", "no suitable {0} found for {1}({2})" },
            { "compiler.err.cant.assign.val.to.final.var", "cannot assign a value to final variable {0}" },
            { "compiler.err.cant.assign.val.to.this", "cannot assign to ''this''" },
            { "compiler.err.cant.deref", "{0} cannot be dereferenced" },
            { "compiler.err.cant.extend.intf.annotation", "''extends'' not allowed for @interfaces" },
            { "compiler.err.cant.infer.local.var.type", "cannot infer type for local variable {0}\n({1})" },
            { "compiler.err.cant.inherit.diff.arg", "{0} cannot be inherited with different arguments: <{1}> and <{2}>" },
            { "compiler.err.cant.inherit.from.anon", "cannot inherit from anonymous class" },
            { "compiler.err.cant.inherit.from.final", "cannot inherit from final {0}" },
            { "compiler.err.cant.read.file", "cannot read: {0}" },
            { "compiler.err.cant.ref.before.ctor.called", "cannot reference {0} before supertype constructor has been called" },
            { "compiler.err.cant.ref.non.effectively.final.var", "local variables referenced from {1} must be final or effectively final" },
            { "compiler.err.cant.resolve", "cannot find symbol\nsymbol: {0} {1}" },
            { "compiler.err.cant.resolve.args", "cannot find symbol\nsymbol: {0} {1}({3})" },
            { "compiler.err.cant.resolve.args.params", "cannot find symbol\nsymbol: {0} <{2}>{1}({3})" },
            { "compiler.err.cant.resolve.location", "cannot find symbol\nsymbol:   {0} {1}\nlocation: {4}" },
            { "compiler.err.cant.resolve.location.args", "cannot find symbol\nsymbol:   {0} {1}({3})\nlocation: {4}" },
            { "compiler.err.cant.resolve.location.args.params", "cannot find symbol\nsymbol:   {0} <{2}>{1}({3})\nlocation: {4}" },
            { "compiler.err.cant.select.static.class.from.param.type", "cannot select a static class from a parameterized type" },
            { "compiler.err.cant.type.annotate.scoping", "scoping construct cannot be annotated with type-use annotations: {0}" },
            { "compiler.err.cant.type.annotate.scoping.1", "scoping construct cannot be annotated with type-use annotation: {0}" },
            { "compiler.err.catch.without.try", "''catch'' without ''try''" },
            { "compiler.err.clash.with.pkg.of.same.name", "{0} {1} clashes with package of same name" },
            { "compiler.err.class.cant.write", "error while writing {0}: {1}" },
            { "compiler.err.class.not.allowed", "class, interface or enum declaration not allowed here" },
            { "compiler.err.class.public.should.be.in.file", "{0} {1} is public, should be declared in a file named {1}.java" },
            { "compiler.err.concrete.inheritance.conflict", "methods {0} from {1} and {2} from {3} are inherited with the same signature" },
            { "compiler.err.conflicting.exports", "duplicate or conflicting exports: {0}" },
            { "compiler.err.conflicting.exports.to.module", "duplicate or conflicting exports to module: {0}" },
            { "compiler.err.conflicting.opens", "duplicate or conflicting opens: {0}" },
            { "compiler.err.conflicting.opens.to.module", "duplicate or conflicting opens to module: {0}" },
            { "compiler.err.const.expr.req", "constant expression required" },
            { "compiler.err.cont.outside.loop", "continue outside of loop" },
            { "compiler.err.cyclic.annotation.element", "type of element {0} is cyclic" },
            { "compiler.err.cyclic.inheritance", "cyclic inheritance involving {0}" },
            { "compiler.err.cyclic.requires", "cyclic dependence involving {0}" },
            { "compiler.err.dc.bad.entity", "bad HTML entity" },
            { "compiler.err.dc.bad.gt", "bad use of ''>''" },
            { "compiler.err.dc.bad.inline.tag", "incorrect use of inline tag" },
            { "compiler.err.dc.gt.expected", "''>'' expected" },
            { "compiler.err.dc.identifier.expected", "identifier expected" },
            { "compiler.err.dc.malformed.html", "malformed HTML" },
            { "compiler.err.dc.missing.semicolon", "semicolon missing" },
            { "compiler.err.dc.no.content", "no content" },
            { "compiler.err.dc.no.tag.name", "no tag name after '@'" },
            { "compiler.err.dc.ref.bad.parens", "'')'' missing in reference" },
            { "compiler.err.dc.ref.syntax.error", "syntax error in reference" },
            { "compiler.err.dc.ref.unexpected.input", "unexpected text" },
            { "compiler.err.dc.unexpected.content", "unexpected content" },
            { "compiler.err.dc.unterminated.inline.tag", "unterminated inline tag" },
            { "compiler.err.dc.unterminated.signature", "unterminated signature" },
            { "compiler.err.dc.unterminated.string", "unterminated string" },
            { "compiler.err.default.allowed.in.intf.annotation.member", "default value only allowed in an annotation type declaration" },
            { "compiler.err.default.overrides.object.member", "default method {0} in {1} {2} overrides a member of java.lang.Object" },
            { "compiler.err.does.not.override.abstract", "{0} is not abstract and does not override abstract method {1} in {2}" },
            { "compiler.err.doesnt.exist", "package {0} does not exist" },
            { "compiler.err.dot.class.expected", "''.class'' expected" },
            { "compiler.err.duplicate.annotation.invalid.repeated", "annotation {0} is not a valid repeatable annotation" },
            { "compiler.err.duplicate.annotation.member.value", "duplicate element ''{0}'' in annotation @{1}." },
            { "compiler.err.duplicate.annotation.missing.container", "{0} is not a repeatable annotation type" },
            { "compiler.err.duplicate.case.label", "duplicate case label" },
            { "compiler.err.duplicate.class", "duplicate class: {0}" },
            { "compiler.err.duplicate.default.label", "duplicate default label" },
            { "compiler.err.duplicate.module", "duplicate module: {0}" },
            { "compiler.err.duplicate.module.on.path", "duplicate module on {0}\nmodule in {1}" },
            { "compiler.err.duplicate.provides", "duplicate provides: service {0}, implementation {1}" },
            { "compiler.err.duplicate.requires", "duplicate requires: {0}" },
            { "compiler.err.duplicate.uses", "duplicate uses: {0}" },
            { "compiler.err.else.without.if", "''else'' without ''if''" },
            { "compiler.err.empty.A.argument", "-A requires an argument; use ''-Akey'' or ''-Akey=value''" },
            { "compiler.err.empty.char.lit", "empty character literal" },
            { "compiler.err.encl.class.required", "an enclosing instance that contains {0} is required" },
            { "compiler.err.enum.annotation.must.be.enum.constant", "an enum annotation value must be an enum constant" },
            { "compiler.err.enum.as.identifier", "as of release 5, ''enum'' is a keyword, and may not be used as an identifier" },
            { "compiler.err.enum.cant.be.instantiated", "enum types may not be instantiated" },
            { "compiler.err.enum.label.must.be.unqualified.enum", "an enum switch case label must be the unqualified name of an enumeration constant" },
            { "compiler.err.enum.no.finalize", "enums cannot have finalize methods" },
            { "compiler.err.enum.no.subclassing", "classes cannot directly extend java.lang.Enum" },
            { "compiler.err.enum.types.not.extensible", "enum types are not extensible" },
            { "compiler.err.enums.must.be.static", "enum declarations allowed only in static contexts" },
            { "compiler.err.error", "error: " },
            { "compiler.err.error.reading.file", "error reading {0}; {1}" },
            { "compiler.err.error.writing.file", "error writing {0}; {1}" },
            { "compiler.err.except.already.caught", "exception {0} has already been caught" },
            { "compiler.err.except.never.thrown.in.try", "exception {0} is never thrown in body of corresponding try statement" },
            { "compiler.err.expected", "{0} expected" },
            { "compiler.err.expected.module", "expected ''module''" },
            { "compiler.err.expected.module.or.open", "''module'' or ''open'' expected" },
            { "compiler.err.expected.str", "{0} expected" },
            { "compiler.err.expected2", "{0} or {1} expected" },
            { "compiler.err.expected3", "{0}, {1}, or {2} expected" },
            { "compiler.err.expression.not.allowable.as.annotation.value", "expression not allowed as annotation value" },
            { "compiler.err.feature.not.supported.in.source", "{0} is not supported in -source {1}\n(use -source {2} or higher to enable {0})" },
            { "compiler.err.feature.not.supported.in.source.plural", "{0} are not supported in -source {1}\n(use -source {2} or higher to enable {0})" },
            { "compiler.err.file.not.directory", "not a directory: {0}" },
            { "compiler.err.file.not.file", "not a file: {0}" },
            { "compiler.err.file.not.found", "file not found: {0}" },
            { "compiler.err.file.patched.and.msp", "file accessible from both --patch-module and --module-source-path, but belongs to a different module on each path: {0}, {1}" },
            { "compiler.err.file.sb.on.source.or.patch.path.for.module", "file should be on source path, or on patch path for module" },
            { "compiler.err.final.parameter.may.not.be.assigned", "final parameter {0} may not be assigned" },
            { "compiler.err.finally.without.try", "''finally'' without ''try''" },
            { "compiler.err.foreach.not.applicable.to.type", "for-each not applicable to expression type\nrequired: {1}\nfound:    {0}" },
            { "compiler.err.fp.number.too.large", "floating point number too large" },
            { "compiler.err.fp.number.too.small", "floating point number too small" },
            { "compiler.err.generic.array.creation", "generic array creation" },
            { "compiler.err.generic.throwable", "a generic class may not extend java.lang.Throwable" },
            { "compiler.err.icls.cant.have.static.decl", "Illegal static declaration in inner class {0}\nmodifier ''static'' is only allowed in constant variable declarations" },
            { "compiler.err.illegal.argument.for.option", "illegal argument for {0}: {1}" },
            { "compiler.err.illegal.array.creation.both.dimension.and.initialization", "array creation with both dimension expression and initialization is illegal" },
            { "compiler.err.illegal.char", "illegal character: ''{0}''" },
            { "compiler.err.illegal.char.for.encoding", "unmappable character (0x{0}) for encoding {1}" },
            { "compiler.err.illegal.combination.of.modifiers", "illegal combination of modifiers: {0} and {1}" },
            { "compiler.err.illegal.default.super.call", "bad type qualifier {0} in default super call\n{1}" },
            { "compiler.err.illegal.dot", "illegal ''.''" },
            { "compiler.err.illegal.enum.static.ref", "illegal reference to static field from initializer" },
            { "compiler.err.illegal.esc.char", "illegal escape character" },
            { "compiler.err.illegal.forward.ref", "illegal forward reference" },
            { "compiler.err.illegal.generic.type.for.instof", "illegal generic type for instanceof" },
            { "compiler.err.illegal.initializer.for.type", "illegal initializer for {0}" },
            { "compiler.err.illegal.line.end.in.char.lit", "illegal line end in character literal" },
            { "compiler.err.illegal.nonascii.digit", "illegal non-ASCII digit" },
            { "compiler.err.illegal.parenthesized.expression", "illegal parenthesized expression" },
            { "compiler.err.illegal.qual.not.icls", "illegal qualifier; {0} is not an inner class" },
            { "compiler.err.illegal.ref.to.var.type", "illegal reference to restricted type ''var''" },
            { "compiler.err.illegal.self.ref", "self-reference in initializer" },
            { "compiler.err.illegal.start.of.expr", "illegal start of expression" },
            { "compiler.err.illegal.start.of.stmt", "illegal start of statement" },
            { "compiler.err.illegal.start.of.type", "illegal start of type" },
            { "compiler.err.illegal.static.intf.meth.call", "illegal static interface method call\nthe receiver expression should be replaced with the type qualifier ''{0}''" },
            { "compiler.err.illegal.underscore", "illegal underscore" },
            { "compiler.err.illegal.unicode.esc", "illegal unicode escape" },
            { "compiler.err.import.requires.canonical", "import requires canonical name for {0}" },
            { "compiler.err.improperly.formed.type.inner.raw.param", "improperly formed type, type arguments given on a raw type" },
            { "compiler.err.improperly.formed.type.param.missing", "improperly formed type, some parameters are missing" },
            { "compiler.err.incomparable.types", "incomparable types: {0} and {1}" },
            { "compiler.err.incompatible.thrown.types.in.mref", "incompatible thrown types {0} in functional expression" },
            { "compiler.err.incorrect.constructor.receiver.name", "the receiver name does not match the enclosing outer class type\nrequired: {0}\nfound: {1}" },
            { "compiler.err.incorrect.constructor.receiver.type", "the receiver type does not match the enclosing outer class type\nrequired: {0}\nfound: {1}" },
            { "compiler.err.incorrect.receiver.name", "the receiver name does not match the enclosing class type\nrequired: {0}\nfound: {1}" },
            { "compiler.err.incorrect.receiver.type", "the receiver type does not match the enclosing class type\nrequired: {0}\nfound: {1}" },
            { "compiler.err.initializer.must.be.able.to.complete.normally", "initializer must be able to complete normally" },
            { "compiler.err.initializer.not.allowed", "initializers not allowed in interfaces" },
            { "compiler.err.int.number.too.large", "integer number too large" },
            { "compiler.err.intf.annotation.cant.have.type.params", "annotation type {0} cannot be generic" },
            { "compiler.err.intf.annotation.member.clash", "annotation type {1} declares an element with the same name as method {0}" },
            { "compiler.err.intf.annotation.members.cant.have.params", "elements in annotation type declarations cannot declare formal parameters" },
            { "compiler.err.intf.annotation.members.cant.have.type.params", "elements in annotation type declarations cannot be generic methods" },
            { "compiler.err.intf.expected.here", "interface expected here" },
            { "compiler.err.intf.meth.cant.have.body", "interface abstract methods cannot have body" },
            { "compiler.err.intf.not.allowed.here", "interface not allowed here" },
            { "compiler.err.invalid.A.key", "key in annotation processor option ''{0}'' is not a dot-separated sequence of identifiers" },
            { "compiler.err.invalid.annotation.member.type", "invalid type for annotation type element" },
            { "compiler.err.invalid.binary.number", "binary numbers must contain at least one binary digit" },
            { "compiler.err.invalid.flag", "invalid flag: {0}" },
            { "compiler.err.invalid.hex.number", "hexadecimal numbers must contain at least one hexadecimal digit" },
            { "compiler.err.invalid.lambda.parameter.declaration", "invalid lambda parameter declaration\n({0})" },
            { "compiler.err.invalid.meth.decl.ret.type.req", "invalid method declaration; return type required" },
            { "compiler.err.invalid.module.directive", "module directive keyword or ''}'' expected" },
            { "compiler.err.invalid.module.specifier", "module specifier not allowed: {0}" },
            { "compiler.err.invalid.mref", "invalid {0} reference\n{1}" },
            { "compiler.err.invalid.profile", "invalid profile: {0}" },
            { "compiler.err.invalid.repeatable.annotation", "duplicate annotation: {0} is annotated with an invalid @Repeatable annotation" },
            { "compiler.err.invalid.repeatable.annotation.elem.nondefault", "containing annotation type ({0}) does not have a default value for element {1}" },
            { "compiler.err.invalid.repeatable.annotation.incompatible.target", "containing annotation type ({0}) is applicable to more targets than repeatable annotation type ({1})" },
            { "compiler.err.invalid.repeatable.annotation.invalid.value", "{0} is not a valid @Repeatable: invalid value element" },
            { "compiler.err.invalid.repeatable.annotation.multiple.values", "{0} is not a valid @Repeatable, {1} element methods named ''value'' declared" },
            { "compiler.err.invalid.repeatable.annotation.no.value", "{0} is not a valid @Repeatable, no value element method declared" },
            { "compiler.err.invalid.repeatable.annotation.not.applicable", "container {0} is not applicable to element {1}" },
            { "compiler.err.invalid.repeatable.annotation.not.applicable.in.context", "container {0} is not applicable in this type context" },
            { "compiler.err.invalid.repeatable.annotation.not.documented", "repeatable annotation type ({1}) is @Documented while containing annotation type ({0}) is not" },
            { "compiler.err.invalid.repeatable.annotation.not.inherited", "repeatable annotation type ({1}) is @Inherited while containing annotation type ({0}) is not" },
            { "compiler.err.invalid.repeatable.annotation.repeated.and.container.present", "container {0} must not be present at the same time as the element it contains" },
            { "compiler.err.invalid.repeatable.annotation.retention", "retention of containing annotation type ({0}) is shorter than the retention of repeatable annotation type ({2})" },
            { "compiler.err.invalid.repeatable.annotation.value.return", "containing annotation type ({0}) must declare an element named ''value'' of type {2}" },
            { "compiler.err.invalid.source", "invalid source release: {0}" },
            { "compiler.err.invalid.target", "invalid target release: {0}" },
            { "compiler.err.io.exception", "error reading source file: {0}" },
            { "compiler.err.label.already.in.use", "label {0} already in use" },
            { "compiler.err.lambda.body.neither.value.nor.void.compatible", "lambda body is neither value nor void compatible" },
            { "compiler.err.limit.code", "code too large" },
            { "compiler.err.limit.code.too.large.for.try.stmt", "code too large for try statement" },
            { "compiler.err.limit.dimensions", "array type has too many dimensions" },
            { "compiler.err.limit.locals", "too many local variables" },
            { "compiler.err.limit.parameters", "too many parameters" },
            { "compiler.err.limit.pool", "too many constants" },
            { "compiler.err.limit.pool.in.class", "too many constants in class {0}" },
            { "compiler.err.limit.stack", "code requires too much stack" },
            { "compiler.err.limit.string", "constant string too long" },
            { "compiler.err.limit.string.overflow", "UTF8 representation for string \"{0}...\" is too long for the constant pool" },
            { "compiler.err.local.enum", "enum types must not be local" },
            { "compiler.err.local.var.accessed.from.icls.needs.final", "local variable {0} is accessed from within inner class; needs to be declared final" },
            { "compiler.err.locn.bad.module-info", "problem reading module-info.class in {0}" },
            { "compiler.err.locn.cant.get.module.name.for.jar", "cannot determine module name for {0}" },
            { "compiler.err.locn.cant.read.directory", "cannot read directory {0}" },
            { "compiler.err.locn.cant.read.file", "cannot read file {0}" },
            { "compiler.err.locn.invalid.arg.for.xpatch", "invalid argument for --patch-module option: {0}" },
            { "compiler.err.locn.module-info.not.allowed.on.patch.path", "module-info.class not allowed on patch path: {0}" },
            { "compiler.err.malformed.fp.lit", "malformed floating point literal" },
            { "compiler.err.method.does.not.override.superclass", "method does not override or implement a method from a supertype" },
            { "compiler.err.missing.meth.body.or.decl.abstract", "missing method body, or declare abstract" },
            { "compiler.err.missing.ret.stmt", "missing return statement" },
            { "compiler.err.mod.not.allowed.here", "modifier {0} not allowed here" },
            { "compiler.err.modifier.not.allowed.here", "modifier {0} not allowed here" },
            { "compiler.err.module.decl.sb.in.module-info.java", "module declarations should be in a file named module-info.java" },
            { "compiler.err.module.name.mismatch", "module name {0} does not match expected name {1}" },
            { "compiler.err.module.non.zero.opens", "open module {0} has non-zero opens_count" },
            { "compiler.err.module.not.found", "module not found: {0}" },
            { "compiler.err.module.not.found.in.module.source.path", "module {0} not found in module source path" },
            { "compiler.err.module.not.found.on.module.source.path", "module not found on module source path" },
            { "compiler.err.modulesourcepath.must.be.specified.with.dash.m.option", "module source path must be specified if -m option is used" },
            { "compiler.err.multi-module.outdir.cannot.be.exploded.module", "in multi-module mode, the output directory cannot be an exploded module: {0}" },
            { "compiler.err.multicatch.parameter.may.not.be.assigned", "multi-catch parameter {0} may not be assigned" },
            { "compiler.err.multicatch.types.must.be.disjoint", "Alternatives in a multi-catch statement cannot be related by subclassing\nAlternative {0} is a subclass of alternative {1}" },
            { "compiler.err.name.clash.same.erasure", "name clash: {0} and {1} have the same erasure" },
            { "compiler.err.name.clash.same.erasure.no.hide", "name clash: {0} in {1} and {2} in {3} have the same erasure, yet neither hides the other" },
            { "compiler.err.name.clash.same.erasure.no.override", "name clash: {0}({1}) in {2} and {3}({4}) in {5} have the same erasure, yet neither overrides the other" },
            { "compiler.err.name.clash.same.erasure.no.override.1", "name clash: {0} {1} has two methods with the same erasure, yet neither overrides the other\nfirst method:  {2}({3}) in {4}\nsecond method: {5}({6}) in {7}" },
            { "compiler.err.name.reserved.for.internal.use", "{0} is reserved for internal use" },
            { "compiler.err.native.meth.cant.have.body", "native methods cannot have a body" },
            { "compiler.err.neither.conditional.subtype", "incompatible types for ?: neither is a subtype of the other\nsecond operand: {0}\nthird operand : {1}" },
            { "compiler.err.new.not.allowed.in.annotation", "''new'' not allowed in an annotation" },
            { "compiler.err.no.annotation.member", "no annotation member {0} in {1}" },
            { "compiler.err.no.annotations.on.dot.class", "no annotations are allowed in the type of a class literal" },
            { "compiler.err.no.encl.instance.of.type.in.scope", "no enclosing instance of type {0} is in scope" },
            { "compiler.err.no.intf.expected.here", "no interface expected here" },
            { "compiler.err.no.match.entry", "{0} has no match in entry in {1}; required {2}" },
            { "compiler.err.no.opens.unless.strong", "''opens'' only allowed in strong modules" },
            { "compiler.err.no.output.dir", "no class output directory specified" },
            { "compiler.err.no.pkg.in.module-info.java", "package declarations not allowed in file module-info.java" },
            { "compiler.err.no.source.files", "no source files" },
            { "compiler.err.no.source.files.classes", "no source files or class names" },
            { "compiler.err.no.superclass", "{0} has no superclass." },
            { "compiler.err.no.value.for.option", "no value for {0} option" },
            { "compiler.err.no.zipfs.for.archive", "No file system provider is available to handle this file: {0}" },
            { "compiler.err.non-static.cant.be.ref", "non-static {0} {1} cannot be referenced from a static context" },
            { "compiler.err.not.annotation.type", "{0} is not an annotation type" },
            { "compiler.err.not.def.access.class.intf.cant.access", "{1}.{0} is defined in an inaccessible class or interface" },
            { "compiler.err.not.def.access.class.intf.cant.access.reason", "{1}.{0} in package {2} is not accessible\n({3})" },
            { "compiler.err.not.def.access.package.cant.access", "{0} is not visible\n({2})" },
            { "compiler.err.not.def.public", "{0} is not public in {1}" },
            { "compiler.err.not.def.public.cant.access", "{0} is not public in {1}; cannot be accessed from outside package" },
            { "compiler.err.not.encl.class", "not an enclosing class: {0}" },
            { "compiler.err.not.in.module.on.module.source.path", "not in a module on the module source path" },
            { "compiler.err.not.in.profile", "{0} is not available in profile ''{1}''" },
            { "compiler.err.not.loop.label", "not a loop label: {0}" },
            { "compiler.err.not.stmt", "not a statement" },
            { "compiler.err.not.within.bounds", "type argument {0} is not within bounds of type-variable {1}" },
            { "compiler.err.operator.cant.be.applied", "bad operand type {1} for unary operator ''{0}''" },
            { "compiler.err.operator.cant.be.applied.1", "bad operand types for binary operator ''{0}''\nfirst type:  {1}\nsecond type: {2}" },
            { "compiler.err.option.not.allowed.with.target", "option {0} not allowed with target {1}" },
            { "compiler.err.option.removed.source", "Source option {0} is no longer supported. Use {1} or later." },
            { "compiler.err.option.removed.target", "Target option {0} is no longer supported. Use {1} or later." },
            { "compiler.err.option.too.many", "option {0} can only be specified once" },
            { "compiler.err.orphaned", "orphaned {0}" },
            { "compiler.err.output.dir.must.be.specified.with.dash.m.option", "class output directory must be specified if -m option is used" },
            { "compiler.err.override.incompatible.ret", "{0}\nreturn type {1} is not compatible with {2}" },
            { "compiler.err.override.meth", "{0}\noverridden method is {1}" },
            { "compiler.err.override.meth.doesnt.throw", "{0}\noverridden method does not throw {1}" },
            { "compiler.err.override.static", "{0}\noverriding method is static" },
            { "compiler.err.override.weaker.access", "{0}\nattempting to assign weaker access privileges; was {1}" },
            { "compiler.err.package.clash.from.requires", "module {0} reads package {1} from both {2} and {3}" },
            { "compiler.err.package.clash.from.requires.in.unnamed", "the unnamed module reads package {0} from both {1} and {2}" },
            { "compiler.err.package.empty.or.not.found", "package is empty or does not exist: {0}" },
            { "compiler.err.package.in.other.module", "package exists in another module: {0}" },
            { "compiler.err.package.not.visible", "package {0} is not visible\n({1})" },
            { "compiler.err.pkg.annotations.sb.in.package-info.java", "package annotations should be in file package-info.java" },
            { "compiler.err.pkg.clashes.with.class.of.same.name", "package {0} clashes with class of same name" },
            { "compiler.err.plugin.not.found", "plug-in not found: {0}" },
            { "compiler.err.premature.eof", "reached end of file while parsing" },
            { "compiler.err.preview.feature.disabled", "{0} is a preview feature and is disabled by default.\n(use --enable-preview to enable {0})" },
            { "compiler.err.preview.feature.disabled.classfile", "classfile for {0} uses preview features of Java SE {1}.\n(use --enable-preview to allow loading of classfiles which contain preview features)" },
            { "compiler.err.preview.feature.disabled.plural", "{0} are a preview feature and are disabled by default.\n(use --enable-preview to enable {0})" },
            { "compiler.err.preview.not.latest", "invalid source release {0} with --enable-preview\n(preview language features are only supported for release {1})" },
            { "compiler.err.preview.without.source.or.release", "--enable-preview must be used with either -source or --release" },
            { "compiler.err.prob.found.req", "incompatible types: {0}" },
            { "compiler.err.proc.bad.config.file", "Bad service configuration file, or exception thrown while constructing Processor object: {0}" },
            { "compiler.err.proc.cant.access", "cannot access {0}\n{1}\nConsult the following stack trace for details.\n{2}" },
            { "compiler.err.proc.cant.access.1", "cannot access {0}\n{1}" },
            { "compiler.err.proc.cant.create.loader", "Could not create class loader for annotation processors: {0}" },
            { "compiler.err.proc.cant.find.class", "Could not find class file for ''{0}''." },
            { "compiler.err.proc.messager", "{0}" },
            { "compiler.err.proc.no.explicit.annotation.processing.requested", "Class names, ''{0}'', are only accepted if annotation processing is explicitly requested" },
            { "compiler.err.proc.no.service", "A ServiceLoader was not usable and is required for annotation processing." },
            { "compiler.err.proc.processor.bad.option.name", "Bad option name ''{0}'' provided by processor ''{1}''" },
            { "compiler.err.proc.processor.cant.instantiate", "Could not instantiate an instance of processor ''{0}''" },
            { "compiler.err.proc.processor.not.found", "Annotation processor ''{0}'' not found" },
            { "compiler.err.proc.processor.wrong.type", "Annotation processor ''{0}'' does not implement javax.annotation.processing.Processor" },
            { "compiler.err.proc.service.problem", "Error creating a service loader to load Processors." },
            { "compiler.err.processorpath.no.processormodulepath", "illegal combination of -processorpath and --processor-module-path" },
            { "compiler.err.profile.bootclasspath.conflict", "profile and bootclasspath options cannot be used together" },
            { "compiler.err.qualified.new.of.static.class", "qualified new of static class" },
            { "compiler.err.receiver.parameter.not.applicable.constructor.toplevel.class", "receiver parameter not applicable for constructor of top-level class" },
            { "compiler.err.recursive.ctor.invocation", "recursive constructor invocation" },
            { "compiler.err.ref.ambiguous", "reference to {0} is ambiguous\nboth {1} {2} in {3} and {4} {5} in {6} match" },
            { "compiler.err.release.bootclasspath.conflict", "option {0} cannot be used together with --release" },
            { "compiler.err.repeated.annotation.target", "repeated annotation target" },
            { "compiler.err.repeated.interface", "repeated interface" },
            { "compiler.err.repeated.modifier", "repeated modifier" },
            { "compiler.err.repeated.provides.for.service", "multiple ''provides'' for service {0}" },
            { "compiler.err.repeated.value.for.patch.module", "--patch-module specified more than once for {0}" },
            { "compiler.err.report.access", "{0} has {1} access in {2}" },
            { "compiler.err.req.arg", "{0} requires an argument" },
            { "compiler.err.ret.outside.meth", "return outside method" },
            { "compiler.err.same.binary.name", "classes: {0} and {1} have the same binary name" },
            { "compiler.err.service.definition.is.enum", "the service definition is an enum: {0}" },
            { "compiler.err.service.implementation.doesnt.have.a.no.args.constructor", "the service implementation does not have a default constructor: {0}" },
            { "compiler.err.service.implementation.is.abstract", "the service implementation is an abstract class: {0}" },
            { "compiler.err.service.implementation.is.inner", "the service implementation is an inner class: {0}" },
            { "compiler.err.service.implementation.must.be.subtype.of.service.interface", "the service implementation type must be a subtype of the service interface type, or have a public static no-args method named \"provider\" returning the service implementation" },
            { "compiler.err.service.implementation.no.args.constructor.not.public", "the no arguments constructor of the service implementation is not public: {0}" },
            { "compiler.err.service.implementation.not.in.right.module", "service implementation must be defined in the same module as the provides directive" },
            { "compiler.err.service.implementation.provider.return.must.be.subtype.of.service.interface", "the \"provider\" method return type must be a subtype of the service interface type" },
            { "compiler.err.signature.doesnt.match.intf", "signature does not match {0}; incompatible interfaces" },
            { "compiler.err.signature.doesnt.match.supertype", "signature does not match {0}; incompatible supertype" },
            { "compiler.err.source.cant.overwrite.input.file", "error writing source; cannot overwrite input file {0}" },
            { "compiler.err.sourcepath.modulesourcepath.conflict", "cannot specify both --source-path and --module-source-path" },
            { "compiler.err.stack.sim.error", "Internal error: stack sim error on {0}" },
            { "compiler.err.static.imp.only.classes.and.interfaces", "static import only from classes and interfaces" },
            { "compiler.err.static.methods.cannot.be.annotated.with.override", "static methods cannot be annotated with @Override" },
            { "compiler.err.string.const.req", "constant string expression required" },
            { "compiler.err.this.as.identifier", "as of release 8, ''this'' is allowed as the parameter name for the receiver type only\nwhich has to be the first parameter, and cannot be a lambda parameter" },
            { "compiler.err.throws.not.allowed.in.intf.annotation", "throws clause not allowed in @interface members" },
            { "compiler.err.too.many.modules", "too many module declarations found" },
            { "compiler.err.too.many.patched.modules", "too many patched modules ({0}), use --module-source-path" },
            { "compiler.err.try.resource.may.not.be.assigned", "auto-closeable resource {0} may not be assigned" },
            { "compiler.err.try.with.resources.expr.effectively.final.var", "variable {0} used as a try-with-resources resource neither final nor effectively final" },
            { "compiler.err.try.with.resources.expr.needs.var", "the try-with-resources resource must either be a variable declaration or an expression denoting a reference to a final or effectively final variable" },
            { "compiler.err.try.without.catch.finally.or.resource.decls", "''try'' without ''catch'', ''finally'' or resource declarations" },
            { "compiler.err.try.without.catch.or.finally", "''try'' without ''catch'' or ''finally''" },
            { "compiler.err.two.class.loaders.1", "javac is split between multiple class loaders: check your configuration" },
            { "compiler.err.two.class.loaders.2", "javac is split between multiple class loaders:\none class comes from file: {0}\nwhile javac comes from {1}" },
            { "compiler.err.type.doesnt.take.params", "type {0} does not take parameters" },
            { "compiler.err.type.found.req", "unexpected type\nrequired: {1}\nfound:    {0}" },
            { "compiler.err.type.var.cant.be.deref", "cannot select from a type variable" },
            { "compiler.err.type.var.may.not.be.followed.by.other.bounds", "a type variable may not be followed by other bounds" },
            { "compiler.err.type.var.more.than.once", "type variable {0} occurs more than once in result type of {1}; cannot be left uninstantiated" },
            { "compiler.err.type.var.more.than.once.in.result", "type variable {0} occurs more than once in type of {1}; cannot be left uninstantiated" },
            { "compiler.err.types.incompatible", "types {0} and {1} are incompatible;\n{2}" },
            { "compiler.err.unclosed.char.lit", "unclosed character literal" },
            { "compiler.err.unclosed.comment", "unclosed comment" },
            { "compiler.err.unclosed.str.lit", "unclosed string literal" },
            { "compiler.err.undef.label", "undefined label: {0}" },
            { "compiler.err.underscore.as.identifier", "as of release 9, ''_'' is a keyword, and may not be used as an identifier" },
            { "compiler.err.underscore.as.identifier.in.lambda", "''_'' used as an identifier\n(use of ''_'' as an identifier is forbidden for lambda parameters)" },
            { "compiler.err.unexpected.lambda", "lambda expression not expected here" },
            { "compiler.err.unexpected.mref", "method reference not expected here" },
            { "compiler.err.unexpected.type", "unexpected type\nrequired: {0}\nfound:    {1}" },
            { "compiler.err.unmatched.quote", "unmatched quote in environment variable {0}" },
            { "compiler.err.unnamed.pkg.not.allowed.named.modules", "unnamed package is not allowed in named modules" },
            { "compiler.err.unreachable.stmt", "unreachable statement" },
            { "compiler.err.unreported.exception.default.constructor", "unreported exception {0} in default constructor" },
            { "compiler.err.unreported.exception.implicit.close", "unreported exception {0}; must be caught or declared to be thrown\nexception thrown from implicit call to close() on resource variable ''{1}''" },
            { "compiler.err.unreported.exception.need.to.catch.or.throw", "unreported exception {0}; must be caught or declared to be thrown" },
            { "compiler.err.unsupported.cross.fp.lit", "hexadecimal floating-point literals are not supported on this VM" },
            { "compiler.err.unsupported.encoding", "unsupported encoding: {0}" },
            { "compiler.err.unsupported.release.version", "release version {0} not supported" },
            { "compiler.err.var.might.already.be.assigned", "variable {0} might already have been assigned" },
            { "compiler.err.var.might.be.assigned.in.loop", "variable {0} might be assigned in loop" },
            { "compiler.err.var.might.not.have.been.initialized", "variable {0} might not have been initialized" },
            { "compiler.err.var.not.allowed", "''var'' not allowed here\nas of release 10, ''var'' is a restricted local variable type and cannot be used for type declarations" },
            { "compiler.err.var.not.allowed.array", "''var'' is not allowed as an element type of an array" },
            { "compiler.err.var.not.allowed.compound", "''var'' is not allowed in a compound declaration" },
            { "compiler.err.var.not.allowed.here", "''var'' is not allowed here" },
            { "compiler.err.var.not.initialized.in.default.constructor", "variable {0} not initialized in the default constructor" },
            { "compiler.err.varargs.and.old.array.syntax", "legacy array notation not allowed on variable-arity parameter" },
            { "compiler.err.varargs.and.receiver", "varargs notation not allowed on receiver parameter" },
            { "compiler.err.varargs.invalid.trustme.anno", "Invalid {0} annotation. {1}" },
            { "compiler.err.varargs.must.be.last", "varargs parameter must be the last parameter" },
            { "compiler.err.variable.not.allowed", "variable declaration not allowed here" },
            { "compiler.err.void.not.allowed.here", "''void'' type not allowed here" },
            { "compiler.err.warnings.and.werror", "warnings found and -Werror specified" },
            { "compiler.err.wrong.number.type.args", "wrong number of type arguments; required {0}" },
            { "compiler.err.wrong.receiver", "wrong receiver parameter name" },
            { "compiler.misc.anachronistic.module.info", "module declaration found in version {0}.{1} classfile" },
            { "compiler.misc.anonymous.class", "<anonymous {0}>" },
            { "compiler.misc.applicable.method.found", "#{0} applicable method found: {1}" },
            { "compiler.misc.applicable.method.found.1", "#{0} applicable method found: {1}\n({2})" },
            { "compiler.misc.arg.length.mismatch", "actual and formal argument lists differ in length" },
            { "compiler.misc.bad.class.file", "class file is invalid for class {0}" },
            { "compiler.misc.bad.class.file.header", "bad class file: {0}\n{1}\nPlease remove or make sure it appears in the correct subdirectory of the classpath." },
            { "compiler.misc.bad.class.signature", "bad class signature: {0}" },
            { "compiler.misc.bad.const.pool.entry", "bad constant pool entry in {0}\nexpected {1} at index {2}" },
            { "compiler.misc.bad.const.pool.tag", "bad constant pool tag: {0}" },
            { "compiler.misc.bad.const.pool.tag.at", "bad constant pool tag: {0} at {1}" },
            { "compiler.misc.bad.constant.range", "constant value ''{0}'' for {1} is outside the expected range for {2}" },
            { "compiler.misc.bad.constant.value", "bad constant value ''{0}'' for {1}, expected {2}" },
            { "compiler.misc.bad.enclosing.class", "bad enclosing class for {0}: {1}" },
            { "compiler.misc.bad.enclosing.method", "bad enclosing method attribute for class {0}" },
            { "compiler.misc.bad.instance.method.in.unbound.lookup", "unexpected instance {0} {1} found in unbound lookup" },
            { "compiler.misc.bad.intersection.target.for.functional.expr", "bad intersection type target for lambda or method reference\n{0}" },
            { "compiler.misc.bad.module-info.name", "bad class name" },
            { "compiler.misc.bad.requires.flag", "bad requires flag: {0}" },
            { "compiler.misc.bad.runtime.invisible.param.annotations", "bad RuntimeInvisibleParameterAnnotations attribute: {0}" },
            { "compiler.misc.bad.signature", "bad signature: {0}" },
            { "compiler.misc.bad.source.file.header", "bad source file: {0}\n{1}\nPlease remove or make sure it appears in the correct subdirectory of the sourcepath." },
            { "compiler.misc.bad.static.method.in.bound.lookup", "unexpected static {0} {1} found in bound lookup" },
            { "compiler.misc.bad.static.method.in.unbound.lookup", "unexpected static {0} {1} found in unbound lookup" },
            { "compiler.misc.bad.type.annotation.value", "bad type annotation target type value: {0}" },
            { "compiler.misc.base.membership", "all your base class are belong to us" },
            { "compiler.misc.cant.access.inner.cls.constr", "cannot access constructor {0}({1})\nan enclosing instance of type {2} is not in scope" },
            { "compiler.misc.cant.apply.diamond.1", "cannot infer type arguments for {0}\nreason: {1}" },
            { "compiler.misc.cant.apply.symbol", "{0} {1} in {4} {5} cannot be applied to given types\nrequired: {2}\nfound: {3}\nreason: {6}" },
            { "compiler.misc.cant.apply.symbols", "no suitable {0} found for {1}({2})" },
            { "compiler.misc.cant.hide", "{0} in {1} cannot hide {2} in {3}" },
            { "compiler.misc.cant.implement", "{0} in {1} cannot implement {2} in {3}" },
            { "compiler.misc.cant.override", "{0} in {1} cannot override {2} in {3}" },
            { "compiler.misc.cant.resolve.args", "cannot find symbol\nsymbol: {0} {1}({3})" },
            { "compiler.misc.cant.resolve.location.args", "cannot find symbol\nsymbol:   {0} {1}({3})\nlocation: {4}" },
            { "compiler.misc.cant.resolve.location.args.params", "cannot find symbol\nsymbol:   {0} <{2}>{1}({3})\nlocation: {4}" },
            { "compiler.misc.cant.resolve.modules", "cannot resolve modules" },
            { "compiler.misc.captured.type", "CAP#{0}" },
            { "compiler.misc.clashes.with", "{0} in {1} clashes with {2} in {3}" },
            { "compiler.misc.class.file.not.found", "class file for {0} not found" },
            { "compiler.misc.class.file.wrong.class", "class file contains wrong class: {0}" },
            { "compiler.misc.conditional.target.cant.be.void", "target-type for conditional expression cannot be void" },
            { "compiler.misc.count.error", "{0} error" },
            { "compiler.misc.count.error.plural", "{0} errors" },
            { "compiler.misc.count.warn", "{0} warning" },
            { "compiler.misc.count.warn.plural", "{0} warnings" },
            { "compiler.misc.descriptor", "descriptor: {2} {0}({1})" },
            { "compiler.misc.descriptor.throws", "descriptor: {2} {0}({1}) throws {3}" },
            { "compiler.misc.diamond", "{0}<>" },
            { "compiler.misc.diamond.and.explicit.params", "cannot use ''<>'' with explicit type parameters for constructor" },
            { "compiler.misc.diamond.anonymous.methods.implicitly.override", "(due to <>, every non-private method declared in this anonymous class must override or implement a method from a supertype)" },
            { "compiler.misc.diamond.invalid.arg", "type argument {0} inferred for {1} is not allowed in this context\ninferred argument is not expressible in the Signature attribute" },
            { "compiler.misc.diamond.invalid.args", "type arguments {0} inferred for {1} are not allowed in this context\ninferred arguments are not expressible in the Signature attribute" },
            { "compiler.misc.diamond.non.generic", "cannot use ''<>'' with non-generic class {0}" },
            { "compiler.misc.eq.bounds", "equality constraints: {0}" },
            { "compiler.misc.exception.message", "{0}" },
            { "compiler.misc.explicit.param.do.not.conform.to.bounds", "explicit type argument {0} does not conform to declared bound(s) {1}" },
            { "compiler.misc.fatal.err.cant.close", "Fatal Error: Cannot close compiler resources" },
            { "compiler.misc.fatal.err.cant.locate.ctor", "Fatal Error: Unable to find constructor for {0}" },
            { "compiler.misc.fatal.err.cant.locate.field", "Fatal Error: Unable to find field {0}" },
            { "compiler.misc.fatal.err.cant.locate.meth", "Fatal Error: Unable to find method {0}" },
            { "compiler.misc.fatal.err.no.java.lang", "Fatal Error: Unable to find package java.lang in classpath or bootclasspath" },
            { "compiler.misc.feature.annotations.after.type.params", "annotations after method type parameters" },
            { "compiler.misc.feature.binary.lit", "binary literals" },
            { "compiler.misc.feature.default.methods", "default methods" },
            { "compiler.misc.feature.diamond", "diamond operator" },
            { "compiler.misc.feature.diamond.and.anon.class", "''<>'' with anonymous inner classes" },
            { "compiler.misc.feature.intersection.types.in.cast", "intersection types" },
            { "compiler.misc.feature.lambda", "lambda expressions" },
            { "compiler.misc.feature.method.references", "method references" },
            { "compiler.misc.feature.modules", "modules" },
            { "compiler.misc.feature.multicatch", "multi-catch statements" },
            { "compiler.misc.feature.not.supported.in.source", "{0} is not supported in -source {1}\n(use -source {2} or higher to enable {0})" },
            { "compiler.misc.feature.not.supported.in.source.plural", "{0} are not supported in -source {1}\n(use -source {2} or higher to enable {0})" },
            { "compiler.misc.feature.private.intf.methods", "private interface methods" },
            { "compiler.misc.feature.repeatable.annotations", "repeated annotations" },
            { "compiler.misc.feature.static.intf.method.invoke", "static interface method invocations" },
            { "compiler.misc.feature.static.intf.methods", "static interface methods" },
            { "compiler.misc.feature.string.switch", "strings in switch" },
            { "compiler.misc.feature.try.with.resources", "try-with-resources" },
            { "compiler.misc.feature.type.annotations", "type annotations" },
            { "compiler.misc.feature.underscore.lit", "underscores in literals" },
            { "compiler.misc.feature.var.in.try.with.resources", "variables in try-with-resources" },
            { "compiler.misc.file.does.not.contain.module", "file does not contain module declaration" },
            { "compiler.misc.file.does.not.contain.package", "file does not contain package {0}" },
            { "compiler.misc.file.doesnt.contain.class", "file does not contain class {0}" },
            { "compiler.misc.illegal.signature", "illegal signature attribute for type {1}" },
            { "compiler.misc.illegal.start.of.class.file", "illegal start of class file" },
            { "compiler.misc.implicit.and.explicit.not.allowed", "cannot mix implicitly-typed and explicitly-typed parameters" },
            { "compiler.misc.inaccessible.varargs.type", "formal varargs element type {0} is not accessible from {1} {2}" },
            { "compiler.misc.inapplicable.method", "{0} {1}.{2} is not applicable\n({3})" },
            { "compiler.misc.incompatible.abstract.default", "{0} {1} inherits abstract and default for {2}({3}) from types {4} and {5}" },
            { "compiler.misc.incompatible.abstracts", "multiple non-overriding abstract methods found in {0} {1}" },
            { "compiler.misc.incompatible.arg.types.in.lambda", "incompatible parameter types in lambda expression" },
            { "compiler.misc.incompatible.arg.types.in.mref", "incompatible parameter types in method reference" },
            { "compiler.misc.incompatible.bounds", "inference variable {0} has incompatible bounds\n{1}\n{2}" },
            { "compiler.misc.incompatible.descs.in.functional.intf", "incompatible function descriptors found in {0} {1}" },
            { "compiler.misc.incompatible.diff.ret", "both define {0}({1}), but with unrelated return types" },
            { "compiler.misc.incompatible.eq.bounds", "inference variable {0} has incompatible equality constraints {1}" },
            { "compiler.misc.incompatible.ret.type.in.lambda", "bad return type in lambda expression\n{0}" },
            { "compiler.misc.incompatible.ret.type.in.mref", "bad return type in method reference\n{0}" },
            { "compiler.misc.incompatible.type.in.conditional", "bad type in conditional expression\n{0}" },
            { "compiler.misc.incompatible.unrelated.defaults", "{0} {1} inherits unrelated defaults for {2}({3}) from types {4} and {5}" },
            { "compiler.misc.incompatible.upper.bounds", "inference variable {0} has incompatible upper bounds {1}" },
            { "compiler.misc.inconvertible.types", "{0} cannot be converted to {1}" },
            { "compiler.misc.infer.arg.length.mismatch", "cannot infer type-variable(s) {0}\n(actual and formal argument lists differ in length)" },
            { "compiler.misc.infer.no.conforming.assignment.exists", "cannot infer type-variable(s) {0}\n(argument mismatch; {1})" },
            { "compiler.misc.infer.no.conforming.instance.exists", "no instance(s) of type variable(s) {0} exist so that {1} conforms to {2}" },
            { "compiler.misc.infer.varargs.argument.mismatch", "cannot infer type-variable(s) {0}\n(varargs mismatch; {1})" },
            { "compiler.misc.inferred.do.not.conform.to.eq.bounds", "inferred type does not conform to equality constraint(s)\ninferred: {0}\nequality constraints(s): {1}" },
            { "compiler.misc.inferred.do.not.conform.to.lower.bounds", "inferred type does not conform to lower bound(s)\ninferred: {0}\nlower bound(s): {1}" },
            { "compiler.misc.inferred.do.not.conform.to.upper.bounds", "inferred type does not conform to upper bound(s)\ninferred: {0}\nupper bound(s): {1}" },
            { "compiler.misc.inner.cls", "an inner class" },
            { "compiler.misc.intersection.type", "INT#{0}" },
            { "compiler.misc.invalid.default.interface", "default method found in version {0}.{1} classfile" },
            { "compiler.misc.invalid.generic.lambda.target", "invalid functional descriptor for lambda expression\nmethod {0} in {1} {2} is generic" },
            { "compiler.misc.invalid.mref", "invalid {0} reference\n{1}" },
            { "compiler.misc.invalid.static.interface", "static method found in version {0}.{1} classfile" },
            { "compiler.misc.kindname.annotation", "@interface" },
            { "compiler.misc.kindname.class", "class" },
            { "compiler.misc.kindname.constructor", "constructor" },
            { "compiler.misc.kindname.enum", "enum" },
            { "compiler.misc.kindname.instance.init", "instance initializer" },
            { "compiler.misc.kindname.interface", "interface" },
            { "compiler.misc.kindname.method", "method" },
            { "compiler.misc.kindname.module", "module" },
            { "compiler.misc.kindname.package", "package" },
            { "compiler.misc.kindname.static", "static" },
            { "compiler.misc.kindname.static.init", "static initializer" },
            { "compiler.misc.kindname.type.variable", "type variable" },
            { "compiler.misc.kindname.type.variable.bound", "bound of type variable" },
            { "compiler.misc.kindname.value", "value" },
            { "compiler.misc.kindname.variable", "variable" },
            { "compiler.misc.lambda", "a lambda expression" },
            { "compiler.misc.local.array.missing.target", "array initializer needs an explicit target-type" },
            { "compiler.misc.local.cant.infer.null", "variable initializer is ''null''" },
            { "compiler.misc.local.cant.infer.void", "variable initializer is ''void''" },
            { "compiler.misc.local.lambda.missing.target", "lambda expression needs an explicit target-type" },
            { "compiler.misc.local.missing.init", "cannot use ''var'' on variable without initializer" },
            { "compiler.misc.local.mref.missing.target", "method reference needs an explicit target-type" },
            { "compiler.misc.local.self.ref", "cannot use ''var'' on self-referencing variable" },
            { "compiler.misc.location", "{0} {1}" },
            { "compiler.misc.location.1", "{0} {1} of type {2}" },
            { "compiler.misc.locn.module_path", "application module path" },
            { "compiler.misc.locn.module_source_path", "module source path" },
            { "compiler.misc.locn.system_modules", "system modules" },
            { "compiler.misc.locn.upgrade_module_path", "upgrade module path" },
            { "compiler.misc.lower.bounds", "lower bounds: {0}" },
            { "compiler.misc.malformed.vararg.method", "class file contains malformed variable arity method: {0}" },
            { "compiler.misc.missing.ret.val", "missing return value" },
            { "compiler.misc.module.info.invalid.super.class", "module-info with invalid super class" },
            { "compiler.misc.module.name.mismatch", "module name {0} does not match expected name {1}" },
            { "compiler.misc.module.non.zero.opens", "open module {0} has non-zero opens_count" },
            { "compiler.misc.mref.infer.and.explicit.params", "cannot use raw constructor reference with explicit type parameters for constructor" },
            { "compiler.misc.no.abstracts", "no abstract method found in {0} {1}" },
            { "compiler.misc.no.args", "no arguments" },
            { "compiler.misc.no.conforming.assignment.exists", "argument mismatch; {0}" },
            { "compiler.misc.no.suitable.functional.intf.inst", "cannot infer functional interface descriptor for {0}" },
            { "compiler.misc.no.unique.maximal.instance.exists", "no unique maximal instance exists for type variable {0} with upper bounds {1}" },
            { "compiler.misc.no.unique.minimal.instance.exists", "no unique minimal instance exists for type variable {0} with lower bounds {1}" },
            { "compiler.misc.not.a.functional.intf", "{0} is not a functional interface" },
            { "compiler.misc.not.a.functional.intf.1", "{0} is not a functional interface\n{1}" },
            { "compiler.misc.not.an.intf.component", "component type {0} is not an interface" },
            { "compiler.misc.not.applicable.method.found", "#{0} not applicable method found: {1}\n({2})" },
            { "compiler.misc.not.def.access.class.intf.cant.access", "{1}.{0} is defined in an inaccessible class or interface" },
            { "compiler.misc.not.def.access.class.intf.cant.access.reason", "{1}.{0} in package {2} is not accessible\n({3})" },
            { "compiler.misc.not.def.access.does.not.read", "package {1} is declared in module {2}, but module {0} does not read it" },
            { "compiler.misc.not.def.access.does.not.read.from.unnamed", "package {0} is declared in module {1}, which is not in the module graph" },
            { "compiler.misc.not.def.access.does.not.read.unnamed", "package {0} is declared in the unnamed module, but module {0} does not read it" },
            { "compiler.misc.not.def.access.not.exported", "package {0} is declared in module {1}, which does not export it" },
            { "compiler.misc.not.def.access.not.exported.from.unnamed", "package {0} is declared in module {1}, which does not export it" },
            { "compiler.misc.not.def.access.not.exported.to.module", "package {0} is declared in module {1}, which does not export it to module {2}" },
            { "compiler.misc.not.def.access.not.exported.to.module.from.unnamed", "package {0} is declared in module {1}, which does not export it to the unnamed module" },
            { "compiler.misc.not.def.access.package.cant.access", "{0} is not visible\n({2})" },
            { "compiler.misc.not.def.public.cant.access", "{0} is not public in {1}; cannot be accessed from outside package" },
            { "compiler.misc.overridden.default", "method {0} is overridden in {1}" },
            { "compiler.misc.package.not.visible", "package {0} is not visible\n({1})" },
            { "compiler.misc.partial.inst.sig", "partially instantiated to: {0}" },
            { "compiler.misc.possible.loss.of.precision", "possible lossy conversion from {0} to {1}" },
            { "compiler.misc.prob.found.req", "incompatible types: {0}" },
            { "compiler.misc.redundant.supertype", "redundant interface {0} is extended by {1}" },
            { "compiler.misc.ref.ambiguous", "reference to {0} is ambiguous\nboth {1} {2} in {3} and {4} {5} in {6} match" },
            { "compiler.misc.report.access", "{0} has {1} access in {2}" },
            { "compiler.misc.resume.abort", "R)esume, A)bort>" },
            { "compiler.misc.source.unavailable", "(source unavailable)" },
            { "compiler.misc.stat.expr.expected", "lambda body is not compatible with a void functional interface\n(consider using a block lambda body, or use a statement expression instead)" },
            { "compiler.misc.static.mref.with.targs", "parameterized qualifier on static method reference" },
            { "compiler.misc.synthetic.name.conflict", "the symbol {0} conflicts with a compiler-synthesized symbol in {1}" },
            { "compiler.misc.token.bad-symbol", "<bad symbol>" },
            { "compiler.misc.token.character", "<character>" },
            { "compiler.misc.token.double", "<double>" },
            { "compiler.misc.token.end-of-input", "<end of input>" },
            { "compiler.misc.token.float", "<float>" },
            { "compiler.misc.token.identifier", "<identifier>" },
            { "compiler.misc.token.integer", "<integer>" },
            { "compiler.misc.token.long-integer", "<long integer>" },
            { "compiler.misc.token.string", "<string>" },
            { "compiler.misc.try.not.applicable.to.type", "try-with-resources not applicable to variable type\n({0})" },
            { "compiler.misc.type.captureof", "capture#{0} of {1}" },
            { "compiler.misc.type.captureof.1", "capture#{0}" },
            { "compiler.misc.type.none", "<none>" },
            { "compiler.misc.type.null", "<null>" },
            { "compiler.misc.type.parameter", "type parameter {0}" },
            { "compiler.misc.type.req.array.or.iterable", "array or java.lang.Iterable" },
            { "compiler.misc.type.req.class", "class" },
            { "compiler.misc.type.req.class.array", "class or array" },
            { "compiler.misc.type.req.exact", "class or interface without bounds" },
            { "compiler.misc.type.req.ref", "reference" },
            { "compiler.misc.type.var", "{0}#{1}" },
            { "compiler.misc.unable.to.access.file", "unable to access file: {0}" },
            { "compiler.misc.unchecked.assign", "unchecked conversion" },
            { "compiler.misc.unchecked.cast.to.type", "unchecked cast" },
            { "compiler.misc.unchecked.clash.with", "{0} in {1} overrides {2} in {3}" },
            { "compiler.misc.unchecked.implement", "{0} in {1} implements {2} in {3}" },
            { "compiler.misc.unchecked.override", "{0} in {1} overrides {2} in {3}" },
            { "compiler.misc.undecl.type.var", "undeclared type variable: {0}" },
            { "compiler.misc.unexpected.ret.val", "unexpected return value" },
            { "compiler.misc.unicode.str.not.supported", "unicode string in class file not supported" },
            { "compiler.misc.unnamed.module", "unnamed module" },
            { "compiler.misc.unnamed.package", "unnamed package" },
            { "compiler.misc.upper.bounds", "lower bounds: {0}" },
            { "compiler.misc.user.selected.completion.failure", "user-selected completion failure by class name" },
            { "compiler.misc.var.and.explicit.not.allowed", "cannot mix ''var'' and explicitly-typed parameters" },
            { "compiler.misc.var.and.implicit.not.allowed", "cannot mix ''var'' and implicitly-typed parameters" },
            { "compiler.misc.varargs.argument.mismatch", "varargs mismatch; {0}" },
            { "compiler.misc.varargs.clash.with", "{0} in {1} overrides {2} in {3}" },
            { "compiler.misc.varargs.implement", "{0} in {1} implements {2} in {3}" },
            { "compiler.misc.varargs.override", "{0} in {1} overrides {2} in {3}" },
            { "compiler.misc.varargs.trustme.on.non.varargs.meth", "Method {0} is not a varargs method." },
            { "compiler.misc.varargs.trustme.on.reifiable.varargs", "Varargs element type {0} is reifiable." },
            { "compiler.misc.varargs.trustme.on.virtual.varargs", "Instance method {0} is neither final nor private." },
            { "compiler.misc.varargs.trustme.on.virtual.varargs.final.only", "Instance method {0} is not final." },
            { "compiler.misc.verbose.checking.attribution", "[checking {0}]" },
            { "compiler.misc.verbose.classpath", "[search path for class files: {0}]" },
            { "compiler.misc.verbose.loading", "[loading {0}]" },
            { "compiler.misc.verbose.parsing.done", "[parsing completed {0}ms]" },
            { "compiler.misc.verbose.parsing.started", "[parsing started {0}]" },
            { "compiler.misc.verbose.sourcepath", "[search path for source files: {0}]" },
            { "compiler.misc.verbose.total", "[total {0}ms]" },
            { "compiler.misc.verbose.wrote.file", "[wrote {0}]" },
            { "compiler.misc.version.not.available", "(version info not available)" },
            { "compiler.misc.where.captured", "{0} extends {1} super: {2} from capture of {3}" },
            { "compiler.misc.where.captured.1", "{0} extends {1} from capture of {3}" },
            { "compiler.misc.where.description.captured", "where {0} is a fresh type-variable:" },
            { "compiler.misc.where.description.captured.1", "where {0} are fresh type-variables:" },
            { "compiler.misc.where.description.intersection", "where {0} is an intersection type:" },
            { "compiler.misc.where.description.intersection.1", "where {0} are intersection types:" },
            { "compiler.misc.where.description.typevar", "where {0} is a type-variable:" },
            { "compiler.misc.where.description.typevar.1", "where {0} are type-variables:" },
            { "compiler.misc.where.fresh.typevar", "{0} extends {1}" },
            { "compiler.misc.where.intersection", "{0} extends {1}" },
            { "compiler.misc.where.typevar", "{0} extends {1} declared in {2} {3}" },
            { "compiler.misc.where.typevar.1", "{0} declared in {2} {3}" },
            { "compiler.misc.wrong.number.type.args", "wrong number of type arguments; required {0}" },
            { "compiler.misc.wrong.version", "class file has wrong version {0}.{1}, should be {2}.{3}" },
            { "compiler.misc.x.print.processor.info", "Processor {0} matches {1} and returns {2}." },
            { "compiler.misc.x.print.rounds", "Round {0}:\n\tinput files: {1}\n\tannotations: {2}\n\tlast round: {3}" },
            { "compiler.note.compressed.diags", "Some messages have been simplified; recompile with -Xdiags:verbose to get full output" },
            { "compiler.note.deferred.method.inst", "Deferred instantiation of method {0}\ninstantiated signature: {1}\ntarget-type: {2}" },
            { "compiler.note.deprecated.filename", "{0} uses or overrides a deprecated API." },
            { "compiler.note.deprecated.filename.additional", "{0} has additional uses or overrides of a deprecated API." },
            { "compiler.note.deprecated.plural", "Some input files use or override a deprecated API." },
            { "compiler.note.deprecated.plural.additional", "Some input files additionally use or override a deprecated API." },
            { "compiler.note.deprecated.recompile", "Recompile with -Xlint:deprecation for details." },
            { "compiler.note.lambda.stat", "Translating lambda expression\nalternate metafactory = {0}\nsynthetic method = {1}" },
            { "compiler.note.mref.stat", "Translating method reference\nalternate metafactory = {0}\n" },
            { "compiler.note.mref.stat.1", "Translating method reference\nalternate metafactory = {0}\nbridge method = {1}" },
            { "compiler.note.multiple.elements", "Multiple elements named ''{1}'' in modules ''{2}'' were found by javax.lang.model.util.Elements.{0}." },
            { "compiler.note.note", "Note: " },
            { "compiler.note.preview.filename", "{0} uses preview language features." },
            { "compiler.note.preview.filename.additional", "{0} has additional uses of preview language features." },
            { "compiler.note.preview.plural", "Some input files use preview language features." },
            { "compiler.note.preview.plural.additional", "Some input files additionally use preview language features." },
            { "compiler.note.preview.recompile", "Recompile with -Xlint:preview for details." },
            { "compiler.note.proc.messager", "{0}" },
            { "compiler.note.removal.filename", "{0} uses or overrides a deprecated API that is marked for removal." },
            { "compiler.note.removal.filename.additional", "{0} has additional uses or overrides of a deprecated API that is marked for removal." },
            { "compiler.note.removal.plural", "Some input files use or override a deprecated API that is marked for removal." },
            { "compiler.note.removal.plural.additional", "Some input files additionally use or override a deprecated API that is marked for removal." },
            { "compiler.note.removal.recompile", "Recompile with -Xlint:removal for details." },
            { "compiler.note.unchecked.filename", "{0} uses unchecked or unsafe operations." },
            { "compiler.note.unchecked.filename.additional", "{0} has additional unchecked or unsafe operations." },
            { "compiler.note.unchecked.plural", "Some input files use unchecked or unsafe operations." },
            { "compiler.note.unchecked.plural.additional", "Some input files additionally use unchecked or unsafe operations." },
            { "compiler.note.unchecked.recompile", "Recompile with -Xlint:unchecked for details." },
            { "compiler.note.verbose.l2m.deduplicate", "deduplicating lambda implementation method {0}" },
            { "compiler.note.verbose.resolve.multi", "resolving method {0} in type {1} to candidate {2}\nphase: {3}\nwith actuals: {4}\nwith type-args: {5}\ncandidates:" },
            { "compiler.note.verbose.resolve.multi.1", "erroneous resolution for method {0} in type {1}\nphase: {3}\nwith actuals: {4}\nwith type-args: {5}\ncandidates:" },
            { "compiler.warn.access.to.member.from.serializable.element", "access to member {0} from serializable element can be publicly accessible to untrusted code" },
            { "compiler.warn.access.to.member.from.serializable.lambda", "access to member {0} from serializable lambda can be publicly accessible to untrusted code" },
            { "compiler.warn.addopens.ignored", "--add-opens has no effect at compile time" },
            { "compiler.warn.annotation.method.not.found", "Cannot find annotation method ''{1}()'' in type ''{0}''" },
            { "compiler.warn.annotation.method.not.found.reason", "Cannot find annotation method ''{1}()'' in type ''{0}'': {2}" },
            { "compiler.warn.auxiliary.class.accessed.from.outside.of.its.source.file", "auxiliary class {0} in {1} should not be accessed from outside its own source file" },
            { "compiler.warn.bad.name.for.option", "bad name in value for {0} option: ''{1}''" },
            { "compiler.warn.big.major.version", "{0}: major version {1} is newer than {2}, the highest major version supported by this compiler.\nIt is recommended that the compiler be upgraded." },
            { "compiler.warn.constant.SVUID", "serialVersionUID must be constant in class {0}" },
            { "compiler.warn.deprecated.annotation.has.no.effect", "@Deprecated annotation has no effect on this {0} declaration" },
            { "compiler.warn.diamond.redundant.args", "Redundant type arguments in new expression (use diamond operator instead)." },
            { "compiler.warn.dir.path.element.not.directory", "bad path element \"{0}\": not a directory" },
            { "compiler.warn.dir.path.element.not.found", "bad path element \"{0}\": no such directory" },
            { "compiler.warn.div.zero", "division by zero" },
            { "compiler.warn.empty.if", "empty statement after if" },
            { "compiler.warn.file.from.future", "Modification date is in the future for file {0}" },
            { "compiler.warn.finally.cannot.complete", "finally clause cannot complete normally" },
            { "compiler.warn.forward.ref", "reference to variable ''{0}'' before it has been initialized" },
            { "compiler.warn.future.attr", "{0} attribute introduced in version {1}.{2} class files is ignored in version {3}.{4} class files" },
            { "compiler.warn.has.been.deprecated", "{0} in {1} has been deprecated" },
            { "compiler.warn.has.been.deprecated.for.removal", "{0} in {1} has been deprecated and marked for removal" },
            { "compiler.warn.has.been.deprecated.for.removal.module", "module {0} has been deprecated and marked for removal" },
            { "compiler.warn.has.been.deprecated.module", "module {0} has been deprecated" },
            { "compiler.warn.illegal.char.for.encoding", "unmappable character for encoding {0}" },
            { "compiler.warn.improper.SVUID", "serialVersionUID must be declared static final in class {0}" },
            { "compiler.warn.incubating.modules", "using incubating module(s): {0}" },
            { "compiler.warn.inexact.non-varargs.call", "non-varargs call of varargs method with inexact argument type for last parameter;\ncast to {0} for a varargs call\ncast to {1} for a non-varargs call and to suppress this warning" },
            { "compiler.warn.invalid.archive.file", "Unexpected file on path: {0}" },
            { "compiler.warn.invalid.path", "Invalid filename: {0}" },
            { "compiler.warn.leaks.not.accessible", "{0} {1} in module {2} is not accessible to clients that require this module" },
            { "compiler.warn.leaks.not.accessible.not.required.transitive", "{0} {1} in module {2} is not indirectly exported using 'requires transitive'" },
            { "compiler.warn.leaks.not.accessible.unexported", "{0} {1} in module {2} is not exported" },
            { "compiler.warn.leaks.not.accessible.unexported.qualified", "{0} {1} in module {2} may not be visible to all clients that require this module" },
            { "compiler.warn.lintOption", "[{0}] " },
            { "compiler.warn.local.redundant.type", "Redundant type for local variable (replace explicit type with ''var'')." },
            { "compiler.warn.locn.unknown.file.on.module.path", "unknown file on module path: {0}" },
            { "compiler.warn.long.SVUID", "serialVersionUID must be of type long in class {0}" },
            { "compiler.warn.method.redundant.typeargs", "Redundant type arguments in method call." },
            { "compiler.warn.missing.SVUID", "serializable class {0} has no definition of serialVersionUID" },
            { "compiler.warn.missing.deprecated.annotation", "deprecated item is not annotated with @Deprecated" },
            { "compiler.warn.module.for.option.not.found", "module name in {0} option not found: {1}" },
            { "compiler.warn.module.not.found", "module not found: {0}" },
            { "compiler.warn.option.obsolete.source", "source value {0} is obsolete and will be removed in a future release" },
            { "compiler.warn.option.obsolete.suppression", "To suppress warnings about obsolete options, use -Xlint:-options." },
            { "compiler.warn.option.obsolete.target", "target value {0} is obsolete and will be removed in a future release" },
            { "compiler.warn.option.parameters.unsupported", "-parameters is not supported for target value {0}. Use {1} or later." },
            { "compiler.warn.outdir.is.in.exploded.module", "the output directory is within an exploded module: {0}" },
            { "compiler.warn.override.bridge", "{0}; overridden method is a bridge method" },
            { "compiler.warn.override.equals.but.not.hashcode", "Class {0} overrides equals, but neither it nor any superclass overrides hashCode method" },
            { "compiler.warn.override.unchecked.ret", "{0}\nreturn type requires unchecked conversion from {1} to {2}" },
            { "compiler.warn.override.unchecked.thrown", "{0}\noverridden method does not throw {1}" },
            { "compiler.warn.override.varargs.extra", "{0}; overriding method is missing ''...''" },
            { "compiler.warn.override.varargs.missing", "{0}; overridden method has no ''...''" },
            { "compiler.warn.package.empty.or.not.found", "package is empty or does not exist: {0}" },
            { "compiler.warn.path.element.not.found", "bad path element \"{0}\": no such file or directory" },
            { "compiler.warn.pkg-info.already.seen", "a package-info.java file has already been seen for package {0}" },
            { "compiler.warn.poor.choice.for.module.name", "module name component {0} should avoid terminal digits" },
            { "compiler.warn.position.overflow", "Position encoding overflows at line {0}" },
            { "compiler.warn.possible.fall-through.into.case", "possible fall-through into case" },
            { "compiler.warn.potential.lambda.found", "This anonymous inner class creation can be turned into a lambda expression." },
            { "compiler.warn.potentially.ambiguous.overload", "{0} in {1} is potentially ambiguous with {2} in {3}" },
            { "compiler.warn.preview.feature.use", "{0} is a preview feature and may be removed in a future release." },
            { "compiler.warn.preview.feature.use.classfile", "classfile for {0} uses preview features of Java SE {1}." },
            { "compiler.warn.preview.feature.use.plural", "{0} are a preview feature and may be removed in a future release." },
            { "compiler.warn.prob.found.req", "{0}\nrequired: {2}\nfound:    {1}" },
            { "compiler.warn.proc.annotations.without.processors", "No processor claimed any of these annotations: {0}" },
            { "compiler.warn.proc.file.create.last.round", "File for type ''{0}'' created in the last round will not be subject to annotation processing." },
            { "compiler.warn.proc.file.reopening", "Attempt to create a file for ''{0}'' multiple times" },
            { "compiler.warn.proc.illegal.file.name", "Cannot create file for illegal name ''{0}''." },
            { "compiler.warn.proc.malformed.supported.string", "Malformed string ''{0}'' for a supported annotation type returned by processor ''{1}''" },
            { "compiler.warn.proc.messager", "{0}" },
            { "compiler.warn.proc.package.does.not.exist", "package {0} does not exist" },
            { "compiler.warn.proc.proc-only.requested.no.procs", "Annotation processing without compilation requested but no processors were found." },
            { "compiler.warn.proc.processor.incompatible.source.version", "Supported source version ''{0}'' from annotation processor ''{1}'' less than -source ''{2}''" },
            { "compiler.warn.proc.suspicious.class.name", "Creating file for a type whose name ends in {1}: ''{0}''" },
            { "compiler.warn.proc.type.already.exists", "A file for type ''{0}'' already exists on the sourcepath or classpath" },
            { "compiler.warn.proc.type.recreate", "Attempt to create a file for type ''{0}'' multiple times" },
            { "compiler.warn.proc.unclosed.type.files", "Unclosed files for the types ''{0}''; these types will not undergo annotation processing" },
            { "compiler.warn.proc.unmatched.processor.options", "The following options were not recognized by any processor: ''{0}''" },
            { "compiler.warn.proc.use.implicit", "Implicitly compiled files were not subject to annotation processing.\nUse -implicit to specify a policy for implicit compilation." },
            { "compiler.warn.proc.use.proc.or.implicit", "Implicitly compiled files were not subject to annotation processing.\nUse -proc:none to disable annotation processing or -implicit to specify a policy for implicit compilation." },
            { "compiler.warn.profile.target.conflict", "profile {0} is not valid for target release {1}" },
            { "compiler.warn.raw.class.use", "found raw type: {0}\nmissing type arguments for generic class {1}" },
            { "compiler.warn.redundant.cast", "redundant cast to {0}" },
            { "compiler.warn.requires.automatic", "requires directive for an automatic module" },
            { "compiler.warn.requires.transitive.automatic", "requires transitive directive for an automatic module" },
            { "compiler.warn.self.ref", "self-reference in initializer of variable ''{0}''" },
            { "compiler.warn.service.provided.but.not.exported.or.used", "service interface provided but not exported or used" },
            { "compiler.warn.source.no.bootclasspath", "bootstrap class path not set in conjunction with -source {0}" },
            { "compiler.warn.source.target.conflict", "source release {0} requires target release {1}" },
            { "compiler.warn.static.not.qualified.by.type", "static {0} should be qualified by type name, {1}, instead of by an expression" },
            { "compiler.warn.sun.proprietary", "{0} is internal proprietary API and may be removed in a future release" },
            { "compiler.warn.target.default.source.conflict", "target release {0} conflicts with default source release {1}" },
            { "compiler.warn.try.explicit.close.call", "explicit call to close() on an auto-closeable resource" },
            { "compiler.warn.try.resource.not.referenced", "auto-closeable resource {0} is never referenced in body of corresponding try statement" },
            { "compiler.warn.try.resource.throws.interrupted.exc", "auto-closeable resource {0} has a member method close() that could throw InterruptedException" },
            { "compiler.warn.unchecked.assign", "unchecked assignment: {0} to {1}" },
            { "compiler.warn.unchecked.assign.to.var", "unchecked assignment to variable {0} as member of raw type {1}" },
            { "compiler.warn.unchecked.call.mbr.of.raw.type", "unchecked call to {0} as a member of the raw type {1}" },
            { "compiler.warn.unchecked.cast.to.type", "unchecked cast to type {0}" },
            { "compiler.warn.unchecked.generic.array.creation", "unchecked generic array creation for varargs parameter of type {0}" },
            { "compiler.warn.unchecked.meth.invocation.applied", "unchecked method invocation: {0} {1} in {4} {5} is applied to given types\nrequired: {2}\nfound: {3}" },
            { "compiler.warn.unchecked.varargs.non.reifiable.type", "Possible heap pollution from parameterized vararg type {0}" },
            { "compiler.warn.underscore.as.identifier", "as of release 9, ''_'' is a keyword, and may not be used as an identifier" },
            { "compiler.warn.unexpected.archive.file", "Unexpected extension for archive file: {0}" },
            { "compiler.warn.unknown.enum.constant", "unknown enum constant {1}.{2}" },
            { "compiler.warn.unknown.enum.constant.reason", "unknown enum constant {1}.{2}\nreason: {3}" },
            { "compiler.warn.unreachable.catch", "unreachable catch clause\nthrown type {0} has already been caught" },
            { "compiler.warn.unreachable.catch.1", "unreachable catch clause\nthrown types {0} have already been caught" },
            { "compiler.warn.var.not.allowed", "as of release 10, ''var'' is a restricted local variable type and cannot be used for type declarations or as the element type of an array" },
            { "compiler.warn.varargs.redundant.trustme.anno", "Redundant {0} annotation. {1}" },
            { "compiler.warn.varargs.unsafe.use.varargs.param", "Varargs method could cause heap pollution from non-reifiable varargs parameter {0}" },
            { "compiler.warn.warning", "warning: " },
        };
    }
}
